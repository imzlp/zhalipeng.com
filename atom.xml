<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Z&#39;s Blog</title>
  <icon>https://imzlp.com/icon.png</icon>
  
  <link href="https://imzlp.com/atom.xml" rel="self"/>
  
  <link href="https://imzlp.com/"/>
  <updated>2021-03-16T02:53:42.349Z</updated>
  <id>https://imzlp.com/</id>
  
  <author>
    <name>查利鹏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UE4热更新：Questions &amp; Answers</title>
    <link href="https://imzlp.com/posts/16895/"/>
    <id>https://imzlp.com/posts/16895/</id>
    <published>2021-03-12T10:45:44.000Z</published>
    <updated>2021-03-16T02:53:42.349Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;项目开源这一年多以来，经过了不少的更新和优化，也被越来越多的开发者选择作为自己项目的热更新方案，期间有不少人陆陆续续询问UE4热更新相关遇到的问题，很多问题比较常见，重复询问的频率也比较多，所以我准备把一些常见的问题进行整理，方便初步上手UE4热更新方案的人能够尽快地排查问题。&lt;/p&gt;
&lt;p&gt;本篇文章会持续更新UE4热更新和&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;相关的Q&amp;amp;A内容，有疑问的地方也可以直接在本篇文章中评论，我会定期统一回答和整理，也可以加入我的UE4热更新群讨论遇到的问题(QQ群958363331)。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/Unreal-Engine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
  </entry>
  
  <entry>
    <title>UE4热更新：Create Shader Patch</title>
    <link href="https://imzlp.com/posts/5867/"/>
    <id>https://imzlp.com/posts/5867/</id>
    <published>2021-03-12T09:49:27.000Z</published>
    <updated>2021-03-16T02:53:42.341Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前的热更新系列文章中介绍了UE热更新的流程和打包细节，其实有一些热更补丁优化的工程实践我觉得也可以详细介绍。&lt;/p&gt;
&lt;p&gt;本篇文章从生成Shader的Patch入手，目的减少每次热更新时的Shader的大小，并会对引擎内部的实现细节做一些分析，解决引擎中的Shader Patch的相关问题，并基于&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;的实现自动化的Shade Patch流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/Unreal-Engine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
    <category term="Shader Patch" scheme="https://imzlp.com/tags/Shader-Patch/"/>
    
    <category term="ushaderbytecode" scheme="https://imzlp.com/tags/ushaderbytecode/"/>
    
  </entry>
  
  <entry>
    <title>UE4的反射实现分析：反射代码生成（一）</title>
    <link href="https://imzlp.com/posts/9780/"/>
    <id>https://imzlp.com/posts/9780/</id>
    <published>2021-03-10T15:14:19.000Z</published>
    <updated>2021-03-16T02:53:42.341Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前写了两篇UE中实现反射的文章分析，介绍了UE的反射基础概念和依赖的一些C++特性，本篇文章开始分析UE反射实现的具体流程。&lt;/p&gt;
&lt;p&gt;C++标准中并没有反射的特性，UE使用的反射是基于&lt;strong&gt;标记语法&lt;/strong&gt;和&lt;strong&gt;UHT扫描生成辅助代码&lt;/strong&gt;来实现的一套机制，正如&lt;a href=&quot;https://en.wikipedia.org/wiki/David_Wheeler_(computer_scientist)&quot;&gt;David Wheeler&lt;/a&gt;的那句名言一样：“&lt;em&gt;All problems in computer science can be solved by another level of indirection&lt;/em&gt;”，UHT做的就是这样的事情，在真正执行编译之前分析标记代码并产生真正的C++代码，收集反射类型的元数据，供运行时之用。&lt;/p&gt;
&lt;p&gt;UHT生成的代码内容很多，为了避免文章组织上的混乱，本篇文章主要讲&lt;code&gt;GENERATED_BODY&lt;/code&gt;/&lt;code&gt;UFUNCTION&lt;/code&gt;等反射标记通过UHT之后生成到&lt;code&gt;generated.h&lt;/code&gt;中的&lt;strong&gt;真正的C++代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;UHT生成的代码分别在&lt;code&gt;generated.h&lt;/code&gt;和&lt;code&gt;gen.cpp&lt;/code&gt;中，&lt;code&gt;generated.h&lt;/code&gt;中的代码大多是定义了一些宏，用在所声明的类内通过编译器预处理来添加通用成员，&lt;code&gt;gen.cpp&lt;/code&gt;中的代码则是UHT基于反射标记生成的用来描述类反射信息的具体代码，&lt;code&gt;genrated.h&lt;/code&gt;和&lt;code&gt;gen.cpp&lt;/code&gt;也是为了声明和定义分离。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="反射" scheme="https://imzlp.com/categories/Unreal-Engine/%E5%8F%8D%E5%B0%84/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="反射" scheme="https://imzlp.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
    <category term="UHT" scheme="https://imzlp.com/tags/UHT/"/>
    
  </entry>
  
  <entry>
    <title>UE4热更新：资产管理与审计工具</title>
    <link href="https://imzlp.com/posts/3675/"/>
    <id>https://imzlp.com/posts/3675/</id>
    <published>2021-03-09T18:16:31.000Z</published>
    <updated>2021-03-16T02:53:42.337Z</updated>
    
    
    <summary type="html">&lt;p&gt;在前面的文章中，介绍了基础包的拆分规则和实现，在基础的打包规则稳定之后，日常开发中的关注重点就转向侧重于项目的资产管理和包体资源审计、分析项目中的资产大小和冗余情况等。&lt;/p&gt;
&lt;p&gt;本篇文章介绍UE中的资源打包配置、常用的资产管理方式以及资产审计工具等工程实践，热更新系列文章的资源管理篇，也是对上一篇文章&lt;a href=&quot;https://imzlp.com/posts/13765/&quot;&gt;UE4热更新：拆分基础包&lt;/a&gt;的内容补充。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/Unreal-Engine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
    <category term="资产审计" scheme="https://imzlp.com/tags/%E8%B5%84%E4%BA%A7%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>UE4热更新：拆分基础包</title>
    <link href="https://imzlp.com/posts/13765/"/>
    <id>https://imzlp.com/posts/13765/</id>
    <published>2021-01-27T21:51:56.000Z</published>
    <updated>2021-03-16T02:53:42.333Z</updated>
    
    
    <summary type="html">&lt;p&gt;在之前的几篇文章中，分别介绍了UE热更新的实现机制，以及热更的自动化流程，近期打算继续写几篇文章介绍下UE里热更新中资源包管理的流程和规则。&lt;/p&gt;
&lt;p&gt;当然，不同类型的项目会有不同的打包策略，资源管理也没有通用的最佳策略。本篇文章主要介绍热更新流程中基础包的拆分的工程实践，涉及修改引擎实现Android/IOS通用拆分方式的方法，希望对不同业务的项目能提供一些有用的思路。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/Unreal-Engine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
  </entry>
  
  <entry>
    <title>UE4热更新：基于HotPatcher的自动化流程</title>
    <link href="https://imzlp.com/posts/10938/"/>
    <id>https://imzlp.com/posts/10938/</id>
    <published>2021-01-24T12:47:34.000Z</published>
    <updated>2021-03-16T02:53:42.333Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;是我之前开源的一个UE4热更新版本管理和资源打包工具，可以方便地进行版本间的差异分析和pak打包。之前的文章为了直观地介绍都是基于手动地在编辑器中进行配置和打包的，在真正的工程实践中，可以自动化的重复操作就要避免手动的参与，较早之前我就在插件中添加了commandlet的支持，近期修复了一些问题以及增加了很多针对commandlet的优化，本篇文章是基于HotPatcher的自动化热更新流程的工程实践。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/Unreal-Engine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
  </entry>
  
  <entry>
    <title>对开源的一些思考与想法</title>
    <link href="https://imzlp.com/posts/8890/"/>
    <id>https://imzlp.com/posts/8890/</id>
    <published>2020-12-18T22:21:02.000Z</published>
    <updated>2021-03-16T02:53:42.333Z</updated>
    
    
    <summary type="html">&lt;p&gt;开源，不仅仅只是需要把代码开放那么简单，而是怎么样用自己的代码去解决实际的需求、进行不断地迭代更新、以及构建开源项目的交流社区。根据过去一两年的开源经历，聊一聊我从开发者角度思考开源的观点以及对开源行为的一点想法。&lt;/p&gt;</summary>
    
    
    
    <category term="编程随想" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"/>
    
    <category term="开源" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/%E5%BC%80%E6%BA%90/"/>
    
    
    <category term="开源" scheme="https://imzlp.com/tags/%E5%BC%80%E6%BA%90/"/>
    
    <category term="编程随想" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>UE4反射实现分析：C++特性</title>
    <link href="https://imzlp.com/posts/23694/"/>
    <id>https://imzlp.com/posts/23694/</id>
    <published>2020-12-13T19:39:37.000Z</published>
    <updated>2021-03-16T02:53:42.333Z</updated>
    
    
    <summary type="html">&lt;p&gt;在前一篇文章中，介绍了UE的反射的基础概念，这篇文章开始研究UE的反射机制的具体实现。&lt;/p&gt;
&lt;p&gt;在介绍UE的代码之前，需要先要介绍一些C++特性，虽然UE的反射实现是大量依赖UHT的代码生成的，但是也需要C++的语法特性支持，只有把这些特性还有它们背后的含义了解清楚，才能够更好地理解UE的反射机制。&lt;/p&gt;
&lt;p&gt;本篇文章中介绍的C++的特性和标准描述均基于&lt;code&gt;ISO/IEC 14882:2014&lt;/code&gt;，也就是C++14标准。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="反射" scheme="https://imzlp.com/categories/Unreal-Engine/%E5%8F%8D%E5%B0%84/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="反射" scheme="https://imzlp.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>UE4反射实现分析：基础概念</title>
    <link href="https://imzlp.com/posts/12624/"/>
    <id>https://imzlp.com/posts/12624/</id>
    <published>2020-12-12T23:56:24.000Z</published>
    <updated>2021-03-16T02:53:42.329Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;反射&lt;/strong&gt;，是指程序在运行时进行自检的的能力，在编辑器的属性面板、序列化、GC等方面非常有用。但是C++语言本身不支持反射特性，UE在C++的语法基础上通过UHT实现了反射信息的生成，从而实现了运行时的反射的目的。&lt;/p&gt;
&lt;p&gt;在之前的文章中，有一些涉及到UE的构建系统和反射相关的内容。&lt;/p&gt;
&lt;p&gt;涉及了UE的构建系统文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/6362/&quot;&gt;Build flow of the Unreal Engine4 project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/16643/&quot;&gt;UE4 Build System：Target and Module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/20425/&quot;&gt;UEC++ 与标准 C++ 的区别与联系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于UE的反射机制来做一些奇淫巧技的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/15049/&quot;&gt;UE4：Hook UObject&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UE的反射实现是依赖于构建系统中UHT来执行代码生成的，本篇文章对UE的反射做一个基础概念介绍，后续会花几篇文章完整地介绍UE里反射的实现机制。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="反射" scheme="https://imzlp.com/categories/Unreal-Engine/%E5%8F%8D%E5%B0%84/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="反射" scheme="https://imzlp.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>2020 Unreal Open Day</title>
    <link href="https://imzlp.com/posts/11043/"/>
    <id>https://imzlp.com/posts/11043/</id>
    <published>2020-12-05T13:38:15.000Z</published>
    <updated>2021-03-16T02:53:42.185Z</updated>
    
    
    <summary type="html">&lt;p&gt;2020年的Unreal Open Day是在线上直播和技术分会场的形式进行的，很开心参加了今年的UOD活动，我录制了一场UOD的技术视频，也去上海直播现场参加了UOD的颁奖活动，很荣幸也很感谢Epic授予我&lt;strong&gt;杰出社区贡献者&lt;/strong&gt;奖项，对我既是认可也是激励，我也会尽力产出更多的技术内容，促进UE社区的发展。&lt;/p&gt;
&lt;p&gt;本篇文章做一个简单的记录，把UOD的资料做一下整理，也把我参加UOD的视频、演讲PPT，以及相关的资料做一个总结，还有一些在UOD直播现场拍的照片。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Unreal Open Day" scheme="https://imzlp.com/tags/Unreal-Open-Day/"/>
    
  </entry>
  
  <entry>
    <title>UE4：UPL与JNI调用的最佳实践</title>
    <link href="https://imzlp.com/posts/27289/"/>
    <id>https://imzlp.com/posts/27289/</id>
    <published>2020-11-15T10:45:27.000Z</published>
    <updated>2021-03-16T02:53:42.181Z</updated>
    
    
    <summary type="html">&lt;p&gt;在使用UE4开发Android时，有时需要获取平台相关的信息、或者执行平台相关的操作，在这种情况下，需要在代码中添加Java的代码以及在C++中调用它们。有些需求也需要在游戏中从Java侧接收一些事件，需要处理Java调用C++的流程。&lt;/p&gt;
&lt;p&gt;本篇文章主要涉及以下几部分内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UE工程中添加Java代码&lt;/li&gt;
&lt;li&gt;Java函数的签名规则&lt;/li&gt;
&lt;li&gt;Java调用C++的函数&lt;/li&gt;
&lt;li&gt;C++调用Java的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何利用UE的UPL特性、Java的签名规则，以及在UE中进行JNI调用实现方法，会在文章中做详细的介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="JNI" scheme="https://imzlp.com/tags/JNI/"/>
    
    <category term="UPL" scheme="https://imzlp.com/tags/UPL/"/>
    
  </entry>
  
  <entry>
    <title>UE4：Hook UObject</title>
    <link href="https://imzlp.com/posts/15049/"/>
    <id>https://imzlp.com/posts/15049/</id>
    <published>2020-11-08T22:35:37.000Z</published>
    <updated>2021-03-16T02:53:42.177Z</updated>
    
    
    <summary type="html">&lt;p&gt;Hook是一种机制，通过拦截和勾取一些事件来实现自己需求的方式。不同于传统的底层Hook，本篇文章主要介绍在UE中如何使用类似Hook的这种机制来实现业务需求。&lt;/p&gt;
&lt;p&gt;有些需求是要全局地修改某个类的所有对象，比如在UI中为某种类型的的Button播放统一的音效，如果在每个控件都需要监听它的OnClicked再去播放音效，会有大量的重复操作。所以，我想要找一种全局的方法，可以监听所有UButton的点击事件，然后统一来处理。再或者想要控制一个在蓝图中不可见的属性，如果只是一些简单的需求就要去修改引擎的代码，有点得不偿失。&lt;/p&gt;
&lt;p&gt;可以通过UE的反射机制来实现这些需求，本篇文章来提供一种思路，做一个简单的实现分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="反射" scheme="https://imzlp.com/categories/Unreal-Engine/%E5%8F%8D%E5%B0%84/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="反射" scheme="https://imzlp.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>BuildGraph：构建支持多平台打包的二进制引擎</title>
    <link href="https://imzlp.com/posts/11956/"/>
    <id>https://imzlp.com/posts/11956/</id>
    <published>2020-11-08T15:40:19.000Z</published>
    <updated>2021-03-16T02:53:42.173Z</updated>
    
    
    <summary type="html">&lt;p&gt;通常，UE4开发者获取UE4引擎的方式有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从Epic Games Launcher安装&lt;/li&gt;
&lt;li&gt;从Github上Clone代码本地编译&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从EpicGamesLauncher安装的是公版引擎，不能修改代码重新编译，可以在根据选择安装支持的平台、调试符号等。&lt;br&gt;自己从Github上Clone代码进行编译的则是源码版引擎，有些功能只能在源码版中使用（比如Standalone Application），但是如果在项目中修改了引擎的代码，导致每个人都需要Clone一遍源码编译一遍引擎，这个过程十分耗时，而且源码版引擎的占用的磁盘空间十分巨大，达到上百G。在当需要把引擎部署到多台构建机时，编译引擎的时间和空间是冗余的，所以需要通过一台机器编译引擎，然后其他的机器只需要拉取编译后的引擎即可，实现与安装版引擎一样的行为。&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍BuildGraph的工作流程，以及对引擎默认构建脚本&lt;code&gt;InstalledEngineBuild.xml&lt;/code&gt;的分析；如何使用BuildGraph从源码配置、编译并导出支持Android/IOS打包的二进制引擎、以及如何裁剪和加速整个的构建流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="构建" scheme="https://imzlp.com/categories/Unreal-Engine/%E6%9E%84%E5%BB%BA/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="BuildGraph" scheme="https://imzlp.com/tags/BuildGraph/"/>
    
  </entry>
  
  <entry>
    <title>二零二零：下一个五年计划</title>
    <link href="https://imzlp.com/posts/27392/"/>
    <id>https://imzlp.com/posts/27392/</id>
    <published>2020-10-25T12:18:58.000Z</published>
    <updated>2021-03-16T02:53:42.173Z</updated>
    
    
    <summary type="html">这是一篇加密文章，请输入密码后阅读。</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>UE4工具集：我的开源项目介绍</title>
    <link href="https://imzlp.com/posts/21696/"/>
    <id>https://imzlp.com/posts/21696/</id>
    <published>2020-10-11T10:33:56.000Z</published>
    <updated>2021-03-16T02:53:42.169Z</updated>
    
    
    <summary type="html">&lt;p&gt;工欲善其事必先利其器，本文主要介绍在我在使用UE的过程中开发的一些开源的工具和插件，能够方便地在项目中使用，提高开发效率。之前简单罗列在&lt;a href=&quot;https://imzlp.com/resources/&quot;&gt;资源&lt;/a&gt;页面里，今天做一个详细的整理，对各个工具、插件做一些介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="开源" scheme="https://imzlp.com/categories/Unreal-Engine/%E5%BC%80%E6%BA%90/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="开源" scheme="https://imzlp.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>如何构建自己的知识体系？</title>
    <link href="https://imzlp.com/posts/29551/"/>
    <id>https://imzlp.com/posts/29551/</id>
    <published>2020-10-10T10:08:52.000Z</published>
    <updated>2021-03-16T02:53:42.169Z</updated>
    
    
    <summary type="html">&lt;p&gt;学习如逆水行舟，不进则退。这一点在CS领域尤甚，新技术、新框架日新月异地发展，业务层面的技术迭代非常快，可能刚熟悉了一项技术，很快就又被淘汰了。所以只有不停地接触、了解和学习新的知识和技能才能不断地拓展自己的程序生涯。&lt;br&gt;本篇文章是我写博客几年的对平时技术积累进行的一些思考，本来当作&lt;a href=&quot;/notes&quot;&gt;notes&lt;/a&gt;改版的记录，现在觉得抽离出来当作单独的文章也比较合适，我很少写感悟类的东西，觉得方法论太虚，但是如果具有理论指导行动的自制力，方法论也是很有必要的，希望自己也能做到。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://imzlp.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="方法论" scheme="https://imzlp.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>UE集成WWise：概念与代码分析</title>
    <link href="https://imzlp.com/posts/9809/"/>
    <id>https://imzlp.com/posts/9809/</id>
    <published>2020-09-12T15:31:46.000Z</published>
    <updated>2021-03-16T02:53:42.153Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.audiokinetic.com/zh/products/wwise/&quot;&gt;WWise&lt;/a&gt;是Audiokinetic的跨平台音频引擎，可以与游戏引擎很好地进行交互，负责音频的同事可以只在WWise中处理音频，把游戏业务和音频的制作与管理分离，提供事件和参数给游戏引擎使用，实现与业务的解耦和对音频更精确的控制。&lt;br&gt;本篇文章主要介绍WWise与UE4的集成、远程构建、资源分析、文档收录，WWise与UE的控制交互以及Bank生成的代码分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="Wwise" scheme="https://imzlp.com/categories/Unreal-Engine/Wwise/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Wwise" scheme="https://imzlp.com/tags/Wwise/"/>
    
  </entry>
  
  <entry>
    <title>UE4导入图集：TexturePacker</title>
    <link href="https://imzlp.com/posts/28513/"/>
    <id>https://imzlp.com/posts/28513/</id>
    <published>2020-09-11T15:53:22.000Z</published>
    <updated>2021-03-16T02:53:42.145Z</updated>
    
    
    <summary type="html">&lt;p&gt;在开发游戏时，会使用到大量的图片资源，使用图集的作用在于减少 DrawCall，提高性能。在UE中没有图集的打包工具，比较流行的方案是使用第三方的图集打包工具&lt;a href=&quot;https://www.codeandweb.com/texturepacker&quot;&gt;TexturePacker&lt;/a&gt;。新版本的TexturePacker支持直接导出UE4的Sprite，并且可以在引擎中直接导入。在之前的版本中可以使用&lt;a href=&quot;https://github.com/ufna/VaTexAtlas&quot;&gt;VaTexAtlas&lt;/a&gt;通过Json Array的数据导入，不过与TexturePacker直接导出UE的Sprite相比，VaTexAtlas并没有优势，UE的Sprite还可以直接预览，VaTexAtlas则不可以，在官方已经支持的情况下不建议再使用VaTexAtlas作为UE导入图集的方式。&lt;/p&gt;
&lt;p&gt;本篇文章主要内容是记录TexturePacker图集生成文件的分析、导入UE、选项介绍、以及记录在UE中使用遇到的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="图集" scheme="https://imzlp.com/categories/Unreal-Engine/%E5%9B%BE%E9%9B%86/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="图集" scheme="https://imzlp.com/tags/%E5%9B%BE%E9%9B%86/"/>
    
    <category term="TexturePackaer" scheme="https://imzlp.com/tags/TexturePackaer/"/>
    
  </entry>
  
  <entry>
    <title>UE4开发笔记：Mac/iOS篇</title>
    <link href="https://imzlp.com/posts/1948/"/>
    <id>https://imzlp.com/posts/1948/</id>
    <published>2020-09-01T21:45:03.000Z</published>
    <updated>2020-09-09T12:29:05.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;本篇文章的主要内容是介绍UE在Mac上的开发环境部署、配置iOS远程出包、UPL在iOS上的应用（介入ipa出包过程）、工具和开发技巧、以及分析相关的引擎代码等内容，记录了一些在项目中遇到的坑，主要从我之前的&lt;a href=&quot;https://imzlp.com/notes&quot;&gt;笔记&lt;/a&gt;中整理而来，后续Mac和iOS相关的内容也都会更新到这篇文章里。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="Apple" scheme="https://imzlp.com/categories/Unreal-Engine/Apple/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="iOS" scheme="https://imzlp.com/tags/iOS/"/>
    
    <category term="Mac" scheme="https://imzlp.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>UE4热更新：需求分析与方案设计</title>
    <link href="https://imzlp.com/posts/17371/"/>
    <id>https://imzlp.com/posts/17371/</id>
    <published>2020-05-16T11:22:35.000Z</published>
    <updated>2021-03-16T02:53:42.117Z</updated>
    
    
    <summary type="html">&lt;p&gt;游戏热更新是在玩家不重新安装游戏的前提下获取最新游戏内容的方式，在PC和移动端的网络游戏中有很多应用，因为游戏上上线后要快速调整、修复bug、更新内容等等。如果每修改一点点内容都需要玩家去AppStore更新应用，甚至去网站手动下载再安装，而且不同的平台对于游戏的审核规则和反馈时间也不一致，运营也会疯掉。&lt;/p&gt;
&lt;p&gt;在其他引擎中的热更应该有比较成熟的方案，但是在UE里还没看到有比较全面的文章来讲UE4的热更实现的文章，恰好之前分析和实现了UE4热更的内容，准备写两篇文章来记录一下思路和实现方案，并会实现一个可以运行的Demo，希望能对有需要的朋友一点帮助。&lt;/p&gt;
&lt;p&gt;为了方便地统一收集和管理热更新和HotPatcher常见的问题与解决方案，我新建了一篇文章来记录和整理：&lt;a href=&quot;https://imzlp.com/posts/16895/&quot;&gt;UE4热更新：Questions &amp;amp; Answers&lt;/a&gt;，遇到问题可以先去看这个FAQ页面。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/Unreal-Engine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
  </entry>
  
  <entry>
    <title>ModularFeature：为UE4集成ZSTD压缩算法</title>
    <link href="https://imzlp.com/posts/8470/"/>
    <id>https://imzlp.com/posts/8470/</id>
    <published>2020-04-20T21:52:56.000Z</published>
    <updated>2021-03-16T02:53:42.113Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE在打包时默认使用&lt;code&gt;Zlib&lt;/code&gt;作为资源的压缩算法，但是从压缩率和解压速度来看它并不是最好的选择，可以从&lt;a href=&quot;https://quixdb.github.io/squash-benchmark/&quot;&gt;Squash Compression Benchmark&lt;/a&gt;去看各种压缩算的效率对比，我选择了facebook开源的&lt;a href=&quot;https://facebook.github.io/zstd/&quot;&gt;ZStandard&lt;/a&gt;作为替换Zlib的压缩实现，因为ZSTD在保证压缩比的同时还具有不错的解压效率。&lt;br&gt;本篇文章并不只是讲怎么在UE里集成一个压缩算法，还会简单介绍一下UE里的一些功能的模块化组织方式——&lt;code&gt;ModularFeature&lt;/code&gt;，使用这种方式可以比较方便地替换某些功能的实现，本文中的替换压缩算法是一个实践。&lt;/p&gt;
&lt;p&gt;我在UE中集成&lt;a href=&quot;https://facebook.github.io/zstd/&quot;&gt;ZSTD&lt;/a&gt;的方式是写了一个插件，源码集成，开源在Github上：&lt;a href=&quot;https://github.com/hxhb/ue4-zstd&quot;&gt;hxhb/ue4-zstd&lt;/a&gt;，支持Android和Windows、IOS以及MacOS，欢迎Star。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
  </entry>
  
  <entry>
    <title>UE4热更新：基于UnLua的Lua编程指南</title>
    <link href="https://imzlp.com/posts/36659/"/>
    <id>https://imzlp.com/posts/36659/</id>
    <published>2020-03-24T10:50:17.000Z</published>
    <updated>2020-05-19T16:57:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE使用的是C++这种编译型语言，在编译之后就成了二进制，只有通过玩家重新安装才能打到更新游戏的目的。但是对于游戏业务而言，对于需求调整和bug修复时间要求非常迫切，频繁地让玩家更新App是不能接受的，游戏项目一般使用Lua作为游戏业务的脚本语言，是为了把运行时不可变的C++代码变成运行时可更新的Lua代码。&lt;/p&gt;
&lt;p&gt;UE官方没有提供Lua的支持，但是腾讯开源了&lt;a href=&quot;https://github.com/Tencent/UnLua&quot;&gt;UnLua&lt;/a&gt;，在我当前的项目使用了，这两天我梳理了一下UnLua的资料（主要是官方文档、issus、宣讲PPT），加上自己测试UnLua写了一个小Demo的感悟，形成了本篇UE结合UnLua的编程指南，主要是总结使用UnLua来写业务的一些基本方法和坑，方便查看，本篇文章会持续更新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;另外，Lua文件打包成Pak可以用我之前开源的工具：&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;hxhb/HotPatcher&lt;/a&gt;，而且我基于UnLua自己修改了一个版本，添加了一些额外的优化，源码集成了&lt;a href=&quot;https://github.com/diegonehab/luasocket&quot;&gt;Luasocket&lt;/a&gt;/&lt;a href=&quot;https://github.com/Tencent/LuaPanda&quot;&gt;Luapanda&lt;/a&gt;/&lt;code&gt;lpeg&lt;/code&gt;/&lt;code&gt;Sproto&lt;/code&gt;/&lt;code&gt;Luacrypt&lt;/code&gt;库，可以直接使用&lt;a href=&quot;https://github.com/Tencent/LuaPanda&quot;&gt;LuaPanda&lt;/a&gt;调试，Github地址为：&lt;a href=&quot;https://github.com/hxhb/debugable-unlua&quot;&gt;hxhb/debugable-unlua&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="Lua" scheme="https://imzlp.com/categories/Unreal-Engine/Lua/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="Lua" scheme="https://imzlp.com/tags/Lua/"/>
    
    <category term="UnLua" scheme="https://imzlp.com/tags/UnLua/"/>
    
  </entry>
  
  <entry>
    <title>UEC++与标准C++的区别与联系</title>
    <link href="https://imzlp.com/posts/20425/"/>
    <id>https://imzlp.com/posts/20425/</id>
    <published>2020-02-11T11:22:44.000Z</published>
    <updated>2021-03-16T02:53:42.105Z</updated>
    
    
    <summary type="html">&lt;p&gt;受&lt;a href=&quot;https://g.co/kgs/oevWTp&quot;&gt;新冠病毒(COVID-19)&lt;/a&gt;影响，整个春节都禁足在家，目前还没有复工，只能看看书整理一下笔记，希望疫情尽快过去，希望朋友们都身体健康。&lt;br&gt;本篇文章的主要内容是分析一下在使用UE开发时使用的C++和**标准C++**在语法上有哪些区别，UEC++本质是C++的一个超集，它支持和使用C++的全部特性，但是它在标准特性之上自己构建了一套语法。很多开发中的编译问题只有知道了两者的边界，才能够快速和准确地定位问题出现在哪个阶段。对于使用UE之前就学习过C++的来说这不是什么问题，但是对于先接触UE然后慢慢学C++的同学来说，这是个挺大的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标准C++**是基于&lt;/strong&gt;ISO/IEC 14882**的语言规范（C++98/03/11/14/17等标准），UEC++则是我们开发当中使用的Epic在标准C++之上扩展的用法，这里不讨论GC、反射之类的基于C++之上自己构建的对象体系，也不涉及UE中的各种库，关注的着重点在于核心语法层面。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/Unreal-Engine/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
  </entry>
  
  <entry>
    <title>UE4源码分析：修改游戏默认的数据存储路径</title>
    <link href="https://imzlp.com/posts/20367/"/>
    <id>https://imzlp.com/posts/20367/</id>
    <published>2020-01-22T09:10:02.000Z</published>
    <updated>2021-03-16T02:53:42.101Z</updated>
    
    
    <summary type="html">&lt;p&gt;默认情况下，使用UE打包出游戏的Apk并在手机上安装之后，启动游戏会在&lt;code&gt;/storage/emulated/0/UE4Game/&lt;/code&gt;下创建游戏的数据目录(也就是内部存储器的根目录下)。按照Google的规则，每个APP的数据文件最好都是放在自己的私有目录，所以我想要把UE打包出来的游戏的数据全放到&lt;code&gt;/storage/emulated/0/Android/data/PACKAGE_NAME&lt;/code&gt;目录中(不管是log、ini、还是crash信息)。&lt;br&gt;一个看似简单的需求，有几种不同的方法，涉及到了UE4的路径管理/JNI/Android Manifest以及对UBT的代码的分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Android" scheme="https://imzlp.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>UE4资源热更打包工具HotPatcher</title>
    <link href="https://imzlp.com/posts/17590/"/>
    <id>https://imzlp.com/posts/17590/</id>
    <published>2020-01-15T09:41:30.000Z</published>
    <updated>2020-08-31T17:27:31.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;是我最近写的用于打包UE项目资源热更的工具，用于追踪工程版本的资源变动来打出Patch。支持一键Cook多平台，一键打包多平台Patch，编辑器支持Windows和MacOS，再写一套从服务器下载patch的流程就是一套完整的游戏热更方案。&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;在项目里已经使用了一段时间，目前比较稳定，今天整理了一下文档，开源出来，会持续更新，欢迎提issus。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxhb/HotPatcher&quot;&gt;HotPatcher&lt;/a&gt;与UnrealFrontEnd中的Patch不同，UE的Patch管理工程时存在一些问题：同样的工程版本，很难在不同的电脑上打出相同的Patch，也无法基于Patch的版本再打出一个Patch，Patch包含的内容不方便预览。在日常开发中还需要能够方便地能够把外部文件打包到pak中（如lua文件、db等non-assets，往往不在Content目录下），并且也需要方便地管理工程和Patch版本。&lt;/p&gt;
&lt;p&gt;这个插件就是为了解决上面这样的问题，以项目资源来记录版本，可以只管理工程本身而无需关注UE生成的其他信息。并且可以方便地进行Cook/生成Pak/提取基础包中的资源信息等操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前支持的引擎版本为UE4.21-UE4.26，最近有很多朋友私信来问插件相关的问题，我创建了个群来讨论UE4热更新和HotPatcher插件的问题(QQ群958363331)，欢迎加入交流UE4相关的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了方便地统一收集和管理热更新和HotPatcher常见的问题与解决方案，我新建了一篇文章来记录和整理：&lt;a href=&quot;https://imzlp.com/posts/16895/&quot;&gt;UE4热更新：Questions &amp;amp; Answers&lt;/a&gt;，遇到问题可以先去看这个FAQ页面。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/categories/Unreal-Engine/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="热更新" scheme="https://imzlp.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    <category term="HotPatcher" scheme="https://imzlp.com/tags/HotPatcher/"/>
    
  </entry>
  
  <entry>
    <title>UE4项目的设计规范和代码标准</title>
    <link href="https://imzlp.com/posts/25915/"/>
    <id>https://imzlp.com/posts/25915/</id>
    <published>2020-01-01T11:55:16.000Z</published>
    <updated>2021-03-16T02:53:42.085Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近新开了项目，大概总结了之前项目的一些问题，列举了一些UE开发项目的设计规范和代码标准（代码标准这个词看起来太严肃了，写代码的习惯是一个比较主观的概念，其实叫代码约定更好，但是在组内推广还是要有严格执行的要求）。本篇文章会持续更新和整理，欢迎指出问题和交流意见。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="代码规范" scheme="https://imzlp.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>成为虚幻商城的内容创作者</title>
    <link href="https://imzlp.com/posts/1927/"/>
    <id>https://imzlp.com/posts/1927/</id>
    <published>2019-12-08T22:49:19.000Z</published>
    <updated>2021-03-16T02:53:42.065Z</updated>
    
    
    <summary type="html">&lt;p&gt;上周我把之前写的一个插件&lt;a href=&quot;https://www.unrealengine.com/marketplace/en-US/slug/exportnavigation&quot;&gt;ExortNavigation&lt;/a&gt;上架了虚幻商城，熟悉了一下UE代码插件的提交流程，在此记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="Marketplace" scheme="https://imzlp.com/categories/Unreal-Engine/Marketplace/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="虚幻商城" scheme="https://imzlp.com/tags/%E8%99%9A%E5%B9%BB%E5%95%86%E5%9F%8E/"/>
    
    <category term="Epic Marketplace" scheme="https://imzlp.com/tags/Epic-Marketplace/"/>
    
  </entry>
  
  <entry>
    <title>Export Recast Navigation Data from UE4</title>
    <link href="https://imzlp.com/posts/20203/"/>
    <id>https://imzlp.com/posts/20203/</id>
    <published>2019-11-01T09:18:13.000Z</published>
    <updated>2021-03-16T02:53:42.013Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/recastnavigation/recastnavigation&quot;&gt;Recast Navigation&lt;/a&gt;是一个开源的游戏导航/寻路引擎，可以为游戏中的AI提供寻路计算。UE和Unity都是集成了RecastNavigation来为游戏提供导航和寻路计算(当然是修改过的版本)，UE的模块&lt;code&gt;NavigationSystem&lt;/code&gt;以及&lt;code&gt;NavMesh&lt;/code&gt;中可以看到相关的代码实现。&lt;br&gt;最近有个需求是要将客户端的地图信息导出给非UE网络架构的服务端，用于在服务器上对玩家位置的校验，想到可以把客户端的生成的导航数据导出作为客户端世界的&lt;strong&gt;地图&lt;/strong&gt;，所以折腾了一下写了一个UE的插件（开源在Github上：**&lt;a href=&quot;https://github.com/hxhb/ue4-export-nav-data&quot;&gt;ue4-export-nav-data&lt;/a&gt;&lt;strong&gt;）实现了&lt;/strong&gt;直接**将UE生成的导航数据导出，有兴趣的可以直接去看具体的代码。&lt;br&gt;根据导出的导航数据可以完整地在非UE网络架构的服务端上实现基于&lt;a href=&quot;https://github.com/recastnavigation/recastnavigation&quot;&gt;Recast Navigation&lt;/a&gt;的寻路计算，而且与UE无缝衔接。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;**2019.12.04 Update:**本插件已上架虚幻商城，购买链接&lt;a href=&quot;https://unrealengine.com/marketplace/en-US/slug/exportnavigation&quot;&gt;ExportNavigation&lt;/a&gt;，为了程序员情怀支持开源，所以该项目在Github上的开源仓库不会关闭，但基本不会更新，如果该插件对你有用，欢迎在商城购买支持作者。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Recast" scheme="https://imzlp.com/tags/Recast/"/>
    
    <category term="Navigation" scheme="https://imzlp.com/tags/Navigation/"/>
    
    <category term="Unreal Engine Plugins" scheme="https://imzlp.com/tags/Unreal-Engine-Plugins/"/>
    
  </entry>
  
  <entry>
    <title>Oculus Quest Development with UE4</title>
    <link href="https://imzlp.com/posts/30042/"/>
    <id>https://imzlp.com/posts/30042/</id>
    <published>2019-09-24T10:41:10.000Z</published>
    <updated>2020-09-17T21:31:19.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.oculus.com/quest/&quot;&gt;Oculus Quest&lt;/a&gt;是Oculus发布的新一代支持6DoF的VR一体机设备，不需要连接PC以及额外的定位基站，而且支持Guardian，当戴着头显走出定位边界时，头显中会立即显示现实中的画面，防止玩家误碰出现意外情况。&lt;br&gt;&lt;a href=&quot;https://www.oculus.com/quest/&quot;&gt;Oculus Quest&lt;/a&gt;使用两个&lt;code&gt;Pentile OLED&lt;/code&gt;的屏幕，单眼分辨率为&lt;code&gt;1440x1600&lt;/code&gt;，刷新率为&lt;code&gt;72Hz&lt;/code&gt;，使用的是&lt;code&gt;arm&lt;/code&gt;架构的高通骁龙835处理器，与两年前的Android旗舰级的处理器相同(如小米6、三星S8)。&lt;br&gt;Quest使用的是&lt;code&gt;Oculus Insight&lt;/code&gt;(inside-out tracing)定位方案，使用四枚摄像头进行位置追踪，分别位于头显面板的四角。&lt;br&gt;发布会时对Oculus Insight的介绍：&lt;a href=&quot;https://www.youtube.com/watch?v=2jY3B_F3GZk&quot;&gt;Oculus Insight VR Positional Tracking System (Sep 2018)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以及国外的一个老哥对Quest追踪范围的测试视频：&lt;a href=&quot;https://drive.google.com/file/d/1-bqNmwUi8J57yykxLP6szgiLeU3IgdgL/view&quot;&gt;Quest Distance Test&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Oculus Quest&lt;/code&gt;64G存储版本的售价为399刀，128G的为499刀，不计税的价格大概是3500；相比较HTC的同类新产品(HTC Vive Focus)是便宜了不少，与PC-Base VR相比那就更具优势了，还不需要一台高性能的主机，我觉得6DoF的VR一体机设备一定是未来的趋势！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;国庆前的OC6，Oculus发布了Oculus Link和finger tracking两项技术，十分厉害，十分看好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整套Quest设备的大小与&lt;code&gt;10.5&lt;/code&gt;寸的iPad差不多，提个小包就能带走：&lt;br&gt;&lt;img data-src=&quot;https://imzlp.com/posts/30042/20190925000314.webp&quot;&gt;&lt;/p&gt;
&lt;p&gt;Quest设备的参数细节不再多说，本篇文章的主要内容是使用UE来开发Quest项目时的环境部署、开发文档、调试工具以及额外的注意事项，会持续更新。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="VR" scheme="https://imzlp.com/categories/Unreal-Engine/VR/"/>
    
    <category term="Quest" scheme="https://imzlp.com/categories/Unreal-Engine/VR/Quest/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="VR" scheme="https://imzlp.com/tags/VR/"/>
    
    <category term="Oculus Quest" scheme="https://imzlp.com/tags/Oculus-Quest/"/>
    
  </entry>
  
  <entry>
    <title>UE4 Build System：Target and Module</title>
    <link href="https://imzlp.com/posts/16643/"/>
    <id>https://imzlp.com/posts/16643/</id>
    <published>2019-09-12T13:14:22.000Z</published>
    <updated>2021-03-16T02:53:41.981Z</updated>
    
    
    <summary type="html">&lt;p&gt;Module是构成Unreal的基本元素，每一个Module封装和实现了一组功能，并且可以供其他的Module使用，整个Unreal Engine就是靠各个Module组合驱动的，连我们创建的游戏项目本身，都是一个单独的Module。&lt;/p&gt;
&lt;p&gt;那么UE又是怎么创建和构建这这些Module的呢？这是写这篇文章的主要目的，研究一下Unreal的构建系统以及它们(Target和Module)支持的各种属性。&lt;/p&gt;
&lt;p&gt;建议在看这篇文章之前先看一下我之前的这篇文章：&lt;a href=&quot;https://imzlp.com/posts/6362/&quot;&gt;Build flow of the Unreal Engine4 project&lt;/a&gt;，主要内容是大致过一遍UE的构建流程，本篇文章只是UE构建系统中的一环。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="Build System" scheme="https://imzlp.com/categories/Unreal-Engine/Build-System/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="UBT" scheme="https://imzlp.com/tags/UBT/"/>
    
  </entry>
  
  <entry>
    <title>UE4工具链配置与开发技巧</title>
    <link href="https://imzlp.com/posts/12143/"/>
    <id>https://imzlp.com/posts/12143/</id>
    <published>2019-09-09T23:32:08.000Z</published>
    <updated>2021-03-16T02:53:41.973Z</updated>
    
    
    <summary type="html">&lt;p&gt;工欲善其事，必先利其器！掌握好的工具会使开发效率上一个层次。&lt;br&gt;本文是我平时记录在&lt;a href=&quot;https://imzlp.com/notes&quot;&gt;notes&lt;/a&gt;中关于UE工具链以及一些组合UE使用的工具配置和使用技巧的笔记整理，后续这方面的内容也会收录到这篇文章中。&lt;br&gt;下面是我之前写的关于UE工具链或扩展相关的单独的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/9050/&quot;&gt;分析UBT中EULA的内容分发限制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/31962/&quot;&gt;Create A Standalone Application in UE4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/6362/&quot;&gt;Build flow of the Unreal Engine4 project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imzlp.com/posts/11515/&quot;&gt;抓取UE4 API并生成带索引的Dash文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
  </entry>
  
  <entry>
    <title>分析UBT中EULA的内容分发限制</title>
    <link href="https://imzlp.com/posts/9050/"/>
    <id>https://imzlp.com/posts/9050/</id>
    <published>2019-08-24T14:15:36.000Z</published>
    <updated>2021-03-16T02:53:41.973Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE的&lt;a href=&quot;https://www.unrealengine.com/en-US/eula&quot;&gt;EULA&lt;/a&gt; &lt;strong&gt;License Grant/(A)**中明确说明了，使用UE开发并再分发的内容不得包含&lt;/strong&gt;未Cook的源格式&lt;strong&gt;和基于&lt;/strong&gt;引擎工具**开发的付费内容，本篇文章研究一下EULA里对内容分发的具体内容和从技术上怎么绕过这个限制。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="UBT" scheme="https://imzlp.com/categories/Unreal-Engine/UBT/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Unreal Engine EULA" scheme="https://imzlp.com/tags/Unreal-Engine-EULA/"/>
    
  </entry>
  
  <entry>
    <title>PixelStreaming：基本概念与上手初探</title>
    <link href="https://imzlp.com/posts/9455/"/>
    <id>https://imzlp.com/posts/9455/</id>
    <published>2019-07-30T17:48:27.000Z</published>
    <updated>2021-03-16T02:53:41.957Z</updated>
    
    
    <summary type="html">&lt;p&gt;PixelStreaming是UE_4.21开始支持的一项技术，简单来说就是能够将游戏跑在服务器上，你可以通过浏览器来玩，玩家端不需要额外操作，只需要一个浏览器，所有的逻辑处理和渲染都在“云”端执行。它不仅仅只是一个插件(虽然有PixelStreamingPlugin这个插件，但它只是&lt;strong&gt;PixelStreaming&lt;/strong&gt;实现中的一环)，其实现具有一套独立与UE游戏的设计和组织方式。&lt;br&gt;本篇文章主要介绍PixelStreaming中的基本概念和使用PixelStreaming的Demo的实际体验。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="PixelStreaming" scheme="https://imzlp.com/categories/Unreal-Engine/PixelStreaming/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Pixel Streaming" scheme="https://imzlp.com/tags/Pixel-Streaming/"/>
    
  </entry>
  
  <entry>
    <title>UE4 Modules:Find the DLL and load it</title>
    <link href="https://imzlp.com/posts/31203/"/>
    <id>https://imzlp.com/posts/31203/</id>
    <published>2019-07-16T18:23:29.000Z</published>
    <updated>2021-03-16T02:53:41.953Z</updated>
    
    
    <summary type="html">&lt;p&gt;在Windows上，UE的模块在非&lt;code&gt;IS_MONOLITHIC&lt;/code&gt;(打包成一个单独的可执行文件的&lt;strong&gt;单片模式(Monolithic)&lt;/strong&gt;)模式下，是通过查找DLL来加载模块的。可以调用&lt;code&gt;FModuleManager&lt;/code&gt;下的&lt;code&gt;LoadModuleWithFailureReason&lt;/code&gt;/&lt;code&gt;LoadModuleChecked&lt;/code&gt;等函数，通过传入Module的字符串名字来加载。&lt;br&gt;本篇文章算是&lt;a href=&quot;https://imzlp.com/posts/24007/&quot;&gt;UE4 Modules:Load and Startup&lt;/a&gt;的扩展和补充，与之不同的是，这篇文章的&lt;strong&gt;侧重点&lt;/strong&gt;在于Module的DLL的查找和加载的细节&lt;strong&gt;而不是&lt;/strong&gt;引擎启动和加载Module的时机和顺序。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Modules" scheme="https://imzlp.com/tags/Modules/"/>
    
  </entry>
  
  <entry>
    <title>UE4接入SteamSDK及相关资料</title>
    <link href="https://imzlp.com/posts/3231/"/>
    <id>https://imzlp.com/posts/3231/</id>
    <published>2019-05-27T23:02:17.000Z</published>
    <updated>2021-03-16T02:53:41.953Z</updated>
    
    
    <summary type="html">&lt;p&gt;游戏上架&lt;a href=&quot;https://store.steampowered.com/&quot;&gt;Steam&lt;/a&gt;必须要接入&lt;a href=&quot;https://partner.steamgames.com/doc/sdk&quot;&gt;SteamSDK&lt;/a&gt;，本篇文章简单介绍一下在UE4中接入&lt;a href=&quot;https://partner.steamgames.com/doc/sdk&quot;&gt;SteamSDK&lt;/a&gt;的方法，后续与接入Steam平台服务相关的内容也会放到这篇文章中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SteamSDK的接入可以使游戏与Steam的社区整合，Steam拥有很好的社区生态，这一点是Epic刚出的&lt;a href=&quot;https://www.epicgames.com/store/e/en-US/&quot;&gt;Epic Games Store&lt;/a&gt;目前比不了的~(当然我是支持市场竞争的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Steam" scheme="https://imzlp.com/tags/Steam/"/>
    
    <category term="SteamSDK" scheme="https://imzlp.com/tags/SteamSDK/"/>
    
  </entry>
  
  <entry>
    <title>UE代码分析:GConfig的加载</title>
    <link href="https://imzlp.com/posts/2386/"/>
    <id>https://imzlp.com/posts/2386/</id>
    <published>2019-05-27T22:57:58.000Z</published>
    <updated>2020-05-28T18:02:53.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE4中提供了一套非常成熟的INI文件配置机制，引擎中也使用了ini作为引擎和项目的配置文件。本篇文章来简单分析一下引擎中GConfig的加载。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
  </entry>
  
  <entry>
    <title>UE4开发的问题笔记和资料辑录</title>
    <link href="https://imzlp.com/posts/25331/"/>
    <id>https://imzlp.com/posts/25331/</id>
    <published>2019-05-27T22:07:50.000Z</published>
    <updated>2021-03-16T02:53:41.913Z</updated>
    
    
    <summary type="html">&lt;p&gt;在平时的开发和学习中遇到和解决的一些问题以及摘录的一些资料，都随手写在了&lt;a href=&quot;https://imzlp.com/notes/&quot;&gt;notes&lt;/a&gt;中，UE相关的积攒了不少，其他的混在一起比较混乱，整理到本篇文章中。&lt;br&gt;与&lt;a href=&quot;https://imzlp.com/posts/3380/&quot;&gt;UE4和VR开发技术笔记&lt;/a&gt;不同的是，这里的内容更偏向于项目中实际的问题记录和资料收集。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
  </entry>
  
  <entry>
    <title>HTC Vive Tracker Developer Guide</title>
    <link href="https://imzlp.com/posts/2125/"/>
    <id>https://imzlp.com/posts/2125/</id>
    <published>2019-04-03T11:41:23.000Z</published>
    <updated>2019-04-10T09:42:32.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;HTC发布的Vive配件&lt;a href=&quot;https://www.vive.com/us/vive-tracker/&quot;&gt;Vive Tracker&lt;/a&gt;可以用来扩展与SteamVR连接的设备。而且还具有Pogo引脚，可以自己DIY出特殊功能的配件，最近看到了一些使用&lt;a href=&quot;https://www.vive.com/us/vive-tracker/&quot;&gt;Vive Tracker&lt;/a&gt;来实现的非常棒的创意。相关的资料和技术细节在本篇文章里整理辑录。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTC Vive" scheme="https://imzlp.com/tags/HTC-Vive/"/>
    
    <category term="Vive Tracker" scheme="https://imzlp.com/tags/Vive-Tracker/"/>
    
    <category term="VR" scheme="https://imzlp.com/tags/VR/"/>
    
    <category term="MR" scheme="https://imzlp.com/tags/MR/"/>
    
  </entry>
  
  <entry>
    <title>Create A Standalone Application in UE4</title>
    <link href="https://imzlp.com/posts/31962/"/>
    <id>https://imzlp.com/posts/31962/</id>
    <published>2019-03-30T18:14:46.000Z</published>
    <updated>2020-03-18T14:10:55.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;虽然UE是个&lt;strong&gt;游戏引擎&lt;/strong&gt;，但并不是只能写游戏——你甚至可以用来写Win32 GUI程序😏.&lt;br&gt;通常，我们使用Editor创建一个UE的游戏项目，然后在其基础上构建自己的类并在游戏中使用。但是如果不想要创建一个游戏项目，UE也支持可以独立运行的程序(Standalone Application)，能够从&lt;code&gt;main&lt;/code&gt;函数来自主构建自己的程序，完全控制启用哪些Modules，而不依赖于引擎本身的逻辑架构，也可以将其作为学习和测试UE模块的轻便方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：UE并没有提供直接创建Standalone Application的方法，我自己写了一个创建&lt;code&gt;Program&lt;/code&gt;项目的工具：&lt;a href=&quot;https://github.com/hxhb/ue4program&quot;&gt;hxhb/ue4program&lt;/a&gt;，并实现了一个独立运行工具的Demo：&lt;a href=&quot;https://github.com/hxhb/UE4Launcher&quot;&gt;hxhb/UE4Launcher&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX数学符号速查表</title>
    <link href="https://imzlp.com/posts/23224/"/>
    <id>https://imzlp.com/posts/23224/</id>
    <published>2019-03-22T00:27:13.000Z</published>
    <updated>2019-03-22T11:25:15.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近读&lt;a href=&quot;https://book.douban.com/subject/30426701/&quot;&gt;龙书DX12&lt;/a&gt;会用到LaTeX来记录一些公式。为了方便查找，整理了一些常用的LaTeX数学符号语法表，更多符号可以看&lt;a href=&quot;https://artofproblemsolving.com/wiki/index.php/LaTeX:Symbols&quot;&gt;LaTeX:Symbols&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="LaTex" scheme="https://imzlp.com/categories/LaTex/"/>
    
    
    <category term="LaTeX" scheme="https://imzlp.com/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>UE4 Modules:Load and Startup</title>
    <link href="https://imzlp.com/posts/24007/"/>
    <id>https://imzlp.com/posts/24007/</id>
    <published>2019-03-19T11:11:57.000Z</published>
    <updated>2019-03-30T15:38:27.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE是模块化的架构，Engine/Game Project/StandaloneApplication/Plugins都是Module(&lt;a href=&quot;http://api.unrealengine.com/INT/API/index.html&quot;&gt;Unreal Engine API Reference&lt;/a&gt;列出了Engine提供的Module列表)，本篇文章从&lt;code&gt;FModuleManager&lt;/code&gt;的代码来分析一下UE的Module是如何通过&lt;code&gt;FModuleManager::LoadModule&lt;/code&gt;加载和启动的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Unreal Engine Modules" scheme="https://imzlp.com/tags/Unreal-Engine-Modules/"/>
    
  </entry>
  
  <entry>
    <title>Build flow of the Unreal Engine4 project</title>
    <link href="https://imzlp.com/posts/6362/"/>
    <id>https://imzlp.com/posts/6362/</id>
    <published>2019-03-16T23:09:52.000Z</published>
    <updated>2019-09-16T19:01:45.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE通过UBT来构建项目(不管是VS里的Build也好，Editor里的Compile也好，最终都会调用UBT)。UBT和UHT是UE工具链的基石，内容太多，没办法一次性分析全部，先梳理出一个大致的轮廓，有时间再慢慢补充。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="UBT" scheme="https://imzlp.com/tags/UBT/"/>
    
    <category term="UHT" scheme="https://imzlp.com/tags/UHT/"/>
    
  </entry>
  
  <entry>
    <title>C++多态与虚函数表</title>
    <link href="https://imzlp.com/posts/25558/"/>
    <id>https://imzlp.com/posts/25558/</id>
    <published>2019-02-26T13:36:47.000Z</published>
    <updated>2019-02-27T11:47:32.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++是一门支持面向对象编程(object-oriented Programming)的语言，继承和多态(Polymorphic)是其最重要的特性。&lt;br&gt;关于C++的继承和类内成员的各种内容在之前的文章中已经有了不少介绍，本篇文章主要是研究一下编译器对C++多态的一个实现方式：&lt;strong&gt;虚函数表&lt;/strong&gt;。&lt;br&gt;C++标准(&lt;strong&gt;[IOS/IEC 14882:2014]&lt;/strong&gt;)中写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Virtual functions support dynamic binding and object-oriented programming. A class that declares or inherits a virtual function is called a polymorphic class.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：&lt;strong&gt;C++标准并没有规定如何实现多态&lt;/strong&gt;，所以编译器对多态的实现是&lt;code&gt;Implementation-defined Behavior&lt;/code&gt;，意思就是不同的编译器可能对多态的实现是不一样的，在&lt;strong&gt;不同的平台可能会无法得到相同的实验结果&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="多态" scheme="https://imzlp.com/tags/%E5%A4%9A%E6%80%81/"/>
    
    <category term="polymorphic" scheme="https://imzlp.com/tags/polymorphic/"/>
    
    <category term="虚函数表" scheme="https://imzlp.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>UE Package Error:ObservedKeyNames.Num()&gt;0</title>
    <link href="https://imzlp.com/posts/359/"/>
    <id>https://imzlp.com/posts/359/</id>
    <published>2019-01-17T09:50:36.000Z</published>
    <updated>2021-03-16T02:53:41.857Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近项目打包时遇到一个非常奇怪的错误：&lt;/p&gt;
&lt;figure class=&quot;highlight txt&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// package log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ensure condition failed: ObservedKeyNames.Num() &amp;gt; 0 [File:D:\Build\++UE4+Release-4.18+Compile\Sync\Engine\Source\Runtime\AIModule\Private\BehaviorTree\Decorators\BTDecorator_BlueprintBase.cpp] [Line: 67]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img data-src=&quot;https://imzlp.com/posts/359/ue-package-error-ObservedKeyNames-Num.png&quot;&gt;&lt;br&gt;我调试了一下UE4的代码，分析了一下原因和解决过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Unreal Engine Package" scheme="https://imzlp.com/tags/Unreal-Engine-Package/"/>
    
  </entry>
  
  <entry>
    <title>Macro defined by UBT in UE4</title>
    <link href="https://imzlp.com/posts/5214/"/>
    <id>https://imzlp.com/posts/5214/</id>
    <published>2019-01-09T18:17:35.000Z</published>
    <updated>2021-03-16T02:53:41.857Z</updated>
    
    
    <summary type="html">&lt;p&gt;UE4引擎里面定义了很多引擎中的宏和一些处理逻辑，如&lt;code&gt;WITH_ENGINE&lt;/code&gt;/&lt;code&gt;WITH_EDITOR&lt;/code&gt;等，它们部分是UBT通过读取&lt;code&gt;*.target.cs&lt;/code&gt;文件中的配置来定义的，有些逻辑是通过读取&lt;code&gt;*.Build.cs&lt;/code&gt;的配置处理的。&lt;br&gt;我读了一下UBT的代码，抽出来部分UBT中配置文件(&lt;code&gt;Target.cs&lt;/code&gt;/&lt;code&gt;Build.cs&lt;/code&gt;)参数与MACRO的相互定义，作为速查手册。&lt;br&gt;&lt;code&gt;*.Target.cs&lt;/code&gt;的参数可以看：&lt;a href=&quot;https://docs.unrealengine.com/en-US/Programming/BuildTools/UnrealBuildTool/TargetFiles/index.html&quot;&gt;UnrealBuildSystem/Targets&lt;/a&gt;&lt;br&gt;&lt;code&gt;*.Build.cs&lt;/code&gt;的参数可以看：&lt;a href=&quot;https://docs.unrealengine.com/en-US/Programming/BuildTools/UnrealBuildTool/ModuleFiles/index.html&quot;&gt;UnrealBuildSystem/ModuleFiles&lt;/a&gt;&lt;br&gt;UE的构建系统文档：&lt;a href=&quot;https://docs.unrealengine.com/en-US/Programming/BuildTools/index.html&quot;&gt;Build Tools&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="UBT" scheme="https://imzlp.com/categories/Unreal-Engine/UBT/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
  </entry>
  
  <entry>
    <title>提取Tor并搭建Tor Bridge</title>
    <link href="https://imzlp.com/posts/11177/"/>
    <id>https://imzlp.com/posts/11177/</id>
    <published>2018-11-04T19:36:04.000Z</published>
    <updated>2018-11-05T10:29:09.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;Tor的Bridge如果传播的范围比较广，可能隔几天就被和谐掉了，频繁地换有点麻烦(恍惚间让我想到了当年改host上Google的时光)。今天折腾了一下，自己在VPS上搭建tor的Bridge来自用。&lt;br&gt;而且也从&lt;a href=&quot;https://www.torproject.org/projects/torbrowser.html.en&quot;&gt;Tor Browser&lt;/a&gt;里提取出tor，使其不依赖Tor Browser，可以供其他浏览器使用。&lt;br&gt;&lt;strong&gt;警告&lt;/strong&gt;：部署Bridge&lt;strong&gt;可能&lt;/strong&gt;会增加服务器被墙的概率。&lt;/p&gt;</summary>
    
    
    
    <category term="网络工具" scheme="https://imzlp.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
    <category term="tor" scheme="https://imzlp.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/tor/"/>
    
    
    <category term="暗网" scheme="https://imzlp.com/tags/%E6%9A%97%E7%BD%91/"/>
    
    <category term="onion" scheme="https://imzlp.com/tags/onion/"/>
    
    <category term="tor" scheme="https://imzlp.com/tags/tor/"/>
    
    <category term="tor bridge" scheme="https://imzlp.com/tags/tor-bridge/"/>
    
  </entry>
  
  <entry>
    <title>动态链接库的使用：加载和链接</title>
    <link href="https://imzlp.com/posts/18949/"/>
    <id>https://imzlp.com/posts/18949/</id>
    <published>2018-10-15T20:50:34.000Z</published>
    <updated>2021-03-16T02:53:41.849Z</updated>
    
    
    <summary type="html">&lt;p&gt;在部分SDK的对接中，有些平台除了DLL外并没有提供导入库来供我们使用，那就只能使用代码中加载DLL的办法来调用DLL内的函数，本文来记录一下两种用法，再分析一下优劣。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="动态链接库" scheme="https://imzlp.com/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>抓取UE4 API并生成带索引的Dash文档</title>
    <link href="https://imzlp.com/posts/11515/"/>
    <id>https://imzlp.com/posts/11515/</id>
    <published>2018-07-05T23:43:43.000Z</published>
    <updated>2020-08-27T22:55:31.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;不知为何，&lt;a href=&quot;http://api.unrealengine.com/INT/API/index.html&quot;&gt;UE API&lt;/a&gt;现在已经不随引擎发布chm的离线文档了，官方发布的最新版本还是2014年的，UE发展到现在有了很多变化，显然四年前的API文档已经丧失部分参考价值了。但是UE文档站自身的搜索功能就我的体验而言，十分的烂。&lt;br&gt;所以折腾了一下把UE API的所有页面爬了下来，并且生成了Dash支持的文档，检索起来十分酸爽。(文后附下载链接)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2020.08.27更新：把API文档更新至UE4.25。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Dash" scheme="https://imzlp.com/tags/Dash/"/>
    
    <category term="Zeal" scheme="https://imzlp.com/tags/Zeal/"/>
    
  </entry>
  
  <entry>
    <title>使用frp进行内网穿透</title>
    <link href="https://imzlp.com/posts/5050/"/>
    <id>https://imzlp.com/posts/5050/</id>
    <published>2018-06-09T11:40:09.000Z</published>
    <updated>2018-11-10T16:19:17.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近想到还有块树莓派在吃灰，今天使用&lt;a href=&quot;https://github.com/fatedier/frp&quot;&gt;frp&lt;/a&gt;折腾了一下内网穿透，把放在家里的树莓派也可以通过外网访问。&lt;/p&gt;</summary>
    
    
    
    <category term="折腾记录" scheme="https://imzlp.com/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    <category term="内网穿透" scheme="https://imzlp.com/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    
    <category term="树莓派" scheme="https://imzlp.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="frp" scheme="https://imzlp.com/tags/frp/"/>
    
    <category term="内网穿透" scheme="https://imzlp.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>UE4和VR开发技术笔记</title>
    <link href="https://imzlp.com/posts/3380/"/>
    <id>https://imzlp.com/posts/3380/</id>
    <published>2018-06-06T08:16:10.000Z</published>
    <updated>2019-01-17T14:00:15.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;平时随笔写下的一些UE4和VR开发中的技术笔记，以及一些相关资料的收录，之前零零散散放在&lt;a href=&quot;https://imzlp.com/notes/&quot;&gt;imzlp.com/notes&lt;/a&gt;中，今天整理了一下，后续的笔记都会放到这篇文章中。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="VR" scheme="https://imzlp.com/tags/VR/"/>
    
  </entry>
  
  <entry>
    <title>Pass Actor To Next Level Through Seamless Travel</title>
    <link href="https://imzlp.com/posts/19376/"/>
    <id>https://imzlp.com/posts/19376/</id>
    <published>2018-04-28T00:43:40.000Z</published>
    <updated>2021-03-16T02:53:41.797Z</updated>
    
    
    <summary type="html">&lt;p&gt;因为UnrealEngine在切换关卡(&lt;code&gt;OpenLevel&lt;/code&gt;)时会把当前关卡的所有对象全部销毁，但是常常我们需要保存某些对象到下一关卡中，今天读了一下相关的代码，本篇文章讲一下如何来实现。&lt;br&gt;其实Unreal的文档是有说明的(&lt;a href=&quot;https://docs.unrealengine.com/en-us/Gameplay/Networking/Travelling&quot;&gt;Travelling in Multiplayer&lt;/a&gt;)，实现起来也并不麻烦，但是UE文档的一贯风格是资料是不详细的，中文资料更是十分匮乏(多是机翻，而且版本很老)，在搜索中也没有查到相关的靠谱的东西，我自己在读代码实现的过程中就随手记了一下，就当做笔记了。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Seamless travel" scheme="https://imzlp.com/tags/Seamless-travel/"/>
    
  </entry>
  
  <entry>
    <title>Build protobuf with MSVC on Windows</title>
    <link href="https://imzlp.com/posts/9903/"/>
    <id>https://imzlp.com/posts/9903/</id>
    <published>2018-02-27T10:01:32.000Z</published>
    <updated>2021-03-16T02:53:41.789Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近有在VS中用到Protobuf，简单记录一下使用MSVC构建Protobuf的流程。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Protobuf" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Protobuf/"/>
    
    
    <category term="Protobuf" scheme="https://imzlp.com/tags/Protobuf/"/>
    
    <category term="序列化" scheme="https://imzlp.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>反向代理Github Pages启用HTTPS</title>
    <link href="https://imzlp.com/posts/18841/"/>
    <id>https://imzlp.com/posts/18841/</id>
    <published>2017-09-07T20:49:29.000Z</published>
    <updated>2018-02-05T13:26:38.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;由于&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;不支持&lt;code&gt;custom domain&lt;/code&gt;的HTTPS，今天折腾了一下搞定了在VPS上用&lt;a href=&quot;https://nginx.org/en/&quot;&gt;Nginx&lt;/a&gt;到&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;的反向代理，使用的是&lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt&lt;/a&gt;签发的证书，实现了全站HTTPS(资源外链也都换成了HTTPS)，简单记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="博客管理" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Hexo" scheme="https://imzlp.com/tags/Hexo/"/>
    
    <category term="博客管理" scheme="https://imzlp.com/tags/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    <category term="Nginx" scheme="https://imzlp.com/tags/Nginx/"/>
    
    <category term="反向代理" scheme="https://imzlp.com/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>为什么不能重载&amp;&amp;与||以及,(comma)？</title>
    <link href="https://imzlp.com/posts/11306/"/>
    <id>https://imzlp.com/posts/11306/</id>
    <published>2017-06-24T22:21:39.000Z</published>
    <updated>2021-03-16T02:53:41.789Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++的基础语法里提供了&lt;code&gt;||&lt;/code&gt;与&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;两个逻辑操作符还有&lt;code&gt;,&lt;/code&gt;(comma)运算符。在类中我们也可以重载这些操作符，但是不要这样做，我会在这篇文章中写出标准描述以及不能重载的原因。&lt;br&gt;概括来说，因为内置的||和&amp;amp;&amp;amp;具有短路求值语义，如果你自己重载了他们就变成了普通的函数调用，会具有与built-in &lt;code&gt;||&lt;/code&gt;与&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;完全不同的语义。&lt;br&gt;而,操作符具有从左到右求值的语义，所以如果自己重载，会变成函数调用，也会具有不同于built-in的语义。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C++技巧" scheme="https://imzlp.com/tags/C-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>C++模板元编程资料辑录</title>
    <link href="https://imzlp.com/posts/23043/"/>
    <id>https://imzlp.com/posts/23043/</id>
    <published>2017-06-17T23:21:33.000Z</published>
    <updated>2021-03-16T02:53:41.789Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文主要是我学习模板元编程过程中的一些心得总结，以及我写的一些模板元编程的代码也都会放到这里来。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="模板元编程" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="模板元编程" scheme="https://imzlp.com/tags/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Template" scheme="https://imzlp.com/tags/Template/"/>
    
  </entry>
  
  <entry>
    <title>operator new：void*到T*的转换</title>
    <link href="https://imzlp.com/posts/21564/"/>
    <id>https://imzlp.com/posts/21564/</id>
    <published>2017-05-22T18:03:33.000Z</published>
    <updated>2021-03-16T02:53:41.789Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C++14标准(C++98/11也一样)中，在&lt;strong&gt;Annex C Compatibility&lt;/strong&gt;里有这么一条：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Change: Converting void* to a pointer-to-object type requires casting&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* b=a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* c=b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;ISO C will accept this usage of pointer to void being assigned to a pointer to object type. C ++ will not.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是为什么&lt;code&gt;operator new()&lt;/code&gt;会返回&lt;code&gt;void*&lt;/code&gt;且不用显式转换为&lt;code&gt;T*&lt;/code&gt;就能赋值给&lt;code&gt;T*&lt;/code&gt;呢？&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>lambda在编译器中实现的方式</title>
    <link href="https://imzlp.com/posts/19441/"/>
    <id>https://imzlp.com/posts/19441/</id>
    <published>2017-05-17T23:35:54.000Z</published>
    <updated>2021-03-16T02:53:41.789Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C++中&lt;code&gt;lambda-expression&lt;/code&gt;的结果叫做&lt;code&gt;闭包对象(closure object)&lt;/code&gt;。本篇文章并非是介绍C++ lambda的用法的(这一点《TC++PL》、《C++ Primer》中都十分详细，或者看我之前的总结&lt;a href=&quot;https://imzlp.com/posts/2441/#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F&quot;&gt;C++11的语法糖#lambda表达式&lt;/a&gt;)，而是从LLVM-IR来分析在Clang中是如何实现&lt;code&gt;lambda-expression&lt;/code&gt;的。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="lambda" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/lambda/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="中间代码" scheme="https://imzlp.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/"/>
    
    <category term="LLVM-IR" scheme="https://imzlp.com/tags/LLVM-IR/"/>
    
    <category term="lambda" scheme="https://imzlp.com/tags/lambda/"/>
    
    <category term="闭包" scheme="https://imzlp.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>访问控制机制的可见性与可访问性</title>
    <link href="https://imzlp.com/posts/17586/"/>
    <id>https://imzlp.com/posts/17586/</id>
    <published>2017-05-13T10:44:06.000Z</published>
    <updated>2021-03-16T02:53:41.789Z</updated>
    
    
    <summary type="html">&lt;p&gt;在上一篇文章&lt;a href=&quot;https://imzlp.com/posts/12080&quot;&gt;突破C++类的访问控制机制&lt;/a&gt;中简略提到了C++类的成员访问控制(&lt;code&gt;public&lt;/code&gt;/&lt;code&gt;protected&lt;/code&gt;/&lt;code&gt;private&lt;/code&gt;)只是限制了成员名字的&lt;strong&gt;可访问性(accessable)**而非&lt;/strong&gt;可见性(visable)**。在这篇文章中主要分析这种性质带来的后果以及如何避免。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="pimpl" scheme="https://imzlp.com/tags/pimpl/"/>
    
  </entry>
  
  <entry>
    <title>突破C++类的访问控制机制</title>
    <link href="https://imzlp.com/posts/12080/"/>
    <id>https://imzlp.com/posts/12080/</id>
    <published>2017-05-12T11:58:05.000Z</published>
    <updated>2019-05-05T10:50:06.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;众所周知，在C++中类成员能够具有三种访问权限，分别为&lt;code&gt;public&lt;/code&gt;/&lt;code&gt;protected&lt;/code&gt;/&lt;code&gt;private&lt;/code&gt;：&lt;br&gt;**[ISO/IEC 14882:2014]**A member of a class can be&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;private&lt;/strong&gt;: that is, its name can be used only by members and friends of the class in which it is declared.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;protected&lt;/strong&gt;: that is, its name can be used only by members and friends of the class in which it is declared, by classes derived from that class, and by their friends (see 11.4).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;public&lt;/strong&gt;: that is, its name can be used anywhere without access restriction.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从标准意图上来看，是希望隐藏类的实现细节和底层数据，即为&lt;strong&gt;封装&lt;/strong&gt;。但是我们也可以通过一些特殊的方式来突破访问权限的限制。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>技术书籍书评汇总</title>
    <link href="https://imzlp.com/posts/15564/"/>
    <id>https://imzlp.com/posts/15564/</id>
    <published>2017-05-06T02:57:42.000Z</published>
    <updated>2021-03-16T02:53:41.789Z</updated>
    
    
    <summary type="html">&lt;p&gt;单独开一篇文章，之前零零散散的书评散落在&lt;a href=&quot;https://imzlp.com/notes&quot;&gt;笔记&lt;/a&gt;和&lt;a href=&quot;https://imzlp.com/tweets&quot;&gt;微言&lt;/a&gt;中，没有具体辑录到一块，不方便索引。以后读过的技术类的书籍之后我会写一些评价就都放到这里来了。因为评价对象是技术书籍，只言片语也不能描述所有的技术细节，本文立意也非“技术笔记”而是“书籍评价”，所以我不会在这里涉及太多书籍中描述的技术细节，只是我作为一个普通读者的阅读感受以及分享我个人的阅读技巧，若其中对某些书透露出褒贬之意均为我个人对书籍的评价无任何贬低作者的意图。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>特殊成员函数的隐式声明及其标准行为</title>
    <link href="https://imzlp.com/posts/21790/"/>
    <id>https://imzlp.com/posts/21790/</id>
    <published>2017-05-04T23:37:05.000Z</published>
    <updated>2021-03-16T02:53:41.789Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C++编程中比较痛恨欲绝的事莫过于：编译器瞒着程序员做了太多事。&lt;br&gt;本篇文章是从C++标准([ISO/IEC 14882:2014])中整理摘录出来的关于编译器生成类的&lt;code&gt;默认构造函数(default constructor)&lt;/code&gt;/&lt;code&gt;拷贝/移动构造函数(copy/move constructor)&lt;/code&gt;/&lt;code&gt;拷贝/移动赋值操作符(copy/move assignment operator)&lt;/code&gt;/&lt;code&gt;析构函数(destructor)&lt;/code&gt;这六个特殊成员函数的几种情况以及其实际行为的文档。可以作为《Inside The C++ Object Model》的辅助资料，组合观看效果更佳(通过标准描述来理解编译器的实现)。&lt;br&gt;另外，《Inside The C++ Object Model》主要是从“编译器实现”的角度来描述的，但是从“C++标准”的角度来看，书里很多是依赖于编译器实现的，就像虚函数表，标准并没有规定编译器应该用何种方式实现多态行为，自然也就不可能描述关于虚函数表的东西。&lt;br&gt;还有很多对于“编译器生成”的行为在主观意识中带有歧义的理解，都可以在这里找到解答，这也是读C++标准的乐趣所在——不论好坏，标准&lt;strong&gt;规定&lt;/strong&gt;不会出错，所有不符合标准描述的实现都是unstandard的。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>函数模板的特化和重载</title>
    <link href="https://imzlp.com/posts/10380/"/>
    <id>https://imzlp.com/posts/10380/</id>
    <published>2017-05-04T00:20:56.000Z</published>
    <updated>2021-03-16T02:53:41.789Z</updated>
    
    
    <summary type="html">&lt;p&gt;不同于类模板，可以具有显式特化和局部特化(partial specializations)，函数模板没有”局部特化”的概念，只有显式特化和重载。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>C++中指向类成员的指针并非指针</title>
    <link href="https://imzlp.com/posts/27615/"/>
    <id>https://imzlp.com/posts/27615/</id>
    <published>2017-04-29T21:28:17.000Z</published>
    <updated>2019-04-22T00:38:56.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;“指向类成员的指针(Pointers to members)”，是一种在C++不常用的特性，但是这里使用术语“指针”略有不妥，因为它们并不包含地址，行为也不像指针。&lt;br&gt;本篇文章会通过LLVM-IR来分析clang中对于“指向类成员的指针”的实现方式，以及穿插C++14标准内定义的相关内容和涉及到的LLVM-IR的语法。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="中间代码" scheme="https://imzlp.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/"/>
    
    <category term="LLVM-IR" scheme="https://imzlp.com/tags/LLVM-IR/"/>
    
  </entry>
  
  <entry>
    <title>为什么需要extern &amp;quot;C&amp;quot;?</title>
    <link href="https://imzlp.com/posts/5392/"/>
    <id>https://imzlp.com/posts/5392/</id>
    <published>2017-04-11T22:20:00.000Z</published>
    <updated>2017-04-24T01:14:08.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;在上一篇文章(&lt;a href=&quot;https://imzlp.com/posts/27118/&quot;&gt;C/C++编译模型分析&lt;/a&gt;)中介绍了C和C++中编译和链接的成因和方式。接上篇文章的坑，本篇文章从&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;着手分析C和C++编译与链接模型中的不同点及其成因，主要为&lt;code&gt;function overload&lt;/code&gt;、&lt;code&gt;function signatures&lt;/code&gt;、&lt;code&gt;name mangling&lt;/code&gt;三个部分。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编译和链接" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编译模型" scheme="https://imzlp.com/tags/%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C/C++编译和链接模型分析</title>
    <link href="https://imzlp.com/posts/27118/"/>
    <id>https://imzlp.com/posts/27118/</id>
    <published>2017-04-10T23:05:44.000Z</published>
    <updated>2017-07-02T00:18:53.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;C和C++均使用分离编译来支持多源文件模块化机制，但是为什么这么做以及如何做是个值得探讨的问题。本篇文章并非是讲述C和C++中如何才能产生不同链接的语法规则，而是分析下C/C++编译器是如何实现编译和链接模型的。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编译和链接" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编译模型" scheme="https://imzlp.com/tags/%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Array of length zero</title>
    <link href="https://imzlp.com/posts/21095/"/>
    <id>https://imzlp.com/posts/21095/</id>
    <published>2017-03-30T19:00:01.000Z</published>
    <updated>2017-03-31T11:48:43.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;看了下在C中&lt;code&gt;Array of length zero&lt;/code&gt;的用法，感觉脑洞大开啊。不过从标准角度(非编译器扩展)来说，这个特性只存在于C语言(C99之后)，C++中是不存在的。先挖个坑，来分析一下。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>虚拟存储器的缺页异常分析</title>
    <link href="https://imzlp.com/posts/30933/"/>
    <id>https://imzlp.com/posts/30933/</id>
    <published>2017-03-22T01:22:02.000Z</published>
    <updated>2021-03-16T02:53:41.781Z</updated>
    
    
    <summary type="html">&lt;p&gt;考虑这样一个问题：能否通过管道(fifo)从一个进程A向另一个进程B(A和B之间并无亲属关系)中传递A进程中对象的地址，从而在进程B中访问到A进程的对象呢？&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://imzlp.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟存储器" scheme="https://imzlp.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
    
    <category term="操作系统" scheme="https://imzlp.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟存储器" scheme="https://imzlp.com/tags/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器的迭代器失效</title>
    <link href="https://imzlp.com/posts/3276/"/>
    <id>https://imzlp.com/posts/3276/</id>
    <published>2017-03-17T11:43:47.000Z</published>
    <updated>2021-03-16T02:53:41.781Z</updated>
    
    
    <summary type="html">&lt;p&gt;容器的大小指的是容器中的元素数目；容器的容量指的是重新分配更多内存之前容器能够保存的元素数目。在改变大小或容量时，元素可能会移动到新的存储位置。这意味着指向元素的迭代器(以及指针或引用)可能会失效(即指向旧元素的位置)。&lt;br&gt;指向关联容器元素的迭代器只有当所指元素从容器中删除时(erase)才会失效。与之相反，指向顺序容器元素的迭代器当重新分配空间(&lt;code&gt;resize()&lt;/code&gt;/&lt;code&gt;reverse()&lt;/code&gt;或&lt;code&gt;push_back()&lt;/code&gt;)或指向元素在容器中移动(如在前一个位置进行&lt;code&gt;erase()&lt;/code&gt;或者&lt;code&gt;insert()&lt;/code&gt;)也会失效。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="STL" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/STL/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="STL" scheme="https://imzlp.com/tags/STL/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>通过IR代码来分析C++代码语义</title>
    <link href="https://imzlp.com/posts/20479/"/>
    <id>https://imzlp.com/posts/20479/</id>
    <published>2017-03-08T11:46:55.000Z</published>
    <updated>2021-03-16T02:53:41.781Z</updated>
    
    
    <summary type="html">&lt;p&gt;IR代码是LLVM生成的&lt;code&gt;Intermediate Code&lt;/code&gt;。可以通过IR代码来分析编译器对我们所写的代码是如何解析并执行的，使得分析代码语义变得简洁明了。IR代码的语法语义可参考&lt;a href=&quot;http://llvm.org/docs/LangRef.html#store-instruction&quot;&gt;LLVM Language Reference Manual&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="中间代码" scheme="https://imzlp.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/"/>
    
    <category term="LLVM-IR" scheme="https://imzlp.com/tags/LLVM-IR/"/>
    
  </entry>
  
  <entry>
    <title>fork/vfork浅谈</title>
    <link href="https://imzlp.com/posts/2658/"/>
    <id>https://imzlp.com/posts/2658/</id>
    <published>2017-03-06T13:40:08.000Z</published>
    <updated>2021-03-16T02:53:41.781Z</updated>
    
    
    <summary type="html">&lt;p&gt;在*UNIX中可以通过fork/vfork来实现多进程编程，整理总结一下相关的知识。&lt;/p&gt;</summary>
    
    
    
    <category term="UNIX" scheme="https://imzlp.com/categories/UNIX/"/>
    
    <category term="POSIX" scheme="https://imzlp.com/categories/UNIX/POSIX/"/>
    
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
    <category term="POSIX" scheme="https://imzlp.com/tags/POSIX/"/>
    
    <category term="多进程" scheme="https://imzlp.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="multi-process" scheme="https://imzlp.com/tags/multi-process/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中的编程技巧及其概念</title>
    <link href="https://imzlp.com/posts/1756/"/>
    <id>https://imzlp.com/posts/1756/</id>
    <published>2017-03-05T01:21:25.000Z</published>
    <updated>2017-04-28T07:53:38.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;一些C++中比较能令人迷惑或者用法比较奇特的示例记录。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="笔记" scheme="https://imzlp.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="notes" scheme="https://imzlp.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>main原型考证及程序终止行为</title>
    <link href="https://imzlp.com/posts/15272/"/>
    <id>https://imzlp.com/posts/15272/</id>
    <published>2017-02-27T15:30:09.000Z</published>
    <updated>2021-03-16T02:53:41.777Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C和C++中流传着很多版本的&lt;code&gt;main&lt;/code&gt;函数原型，不同的书里也有不同的写法。今天我从几种标准(C89/99/11以及C++98/03/11/14)的角度来寻找一下什么是“&lt;strong&gt;标准行为&lt;/strong&gt;”以及在主函数中return后发生了什么。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>C和C++之间的不兼容</title>
    <link href="https://imzlp.com/posts/14446/"/>
    <id>https://imzlp.com/posts/14446/</id>
    <published>2017-02-27T15:25:56.000Z</published>
    <updated>2017-05-23T10:46:52.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前提到过数次C和C++并不是一个语言，就算是C++中从C继承来的那部分也和ISO C有很大区别，以后我会逐渐整理一些它们之间不兼容的特性到这里来。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>C++中declaration与define的区别</title>
    <link href="https://imzlp.com/posts/21831/"/>
    <id>https://imzlp.com/posts/21831/</id>
    <published>2017-02-24T21:09:53.000Z</published>
    <updated>2021-03-16T02:53:41.777Z</updated>
    
    
    <summary type="html">&lt;p&gt;看过不少C++的书籍里都没有明确地指出处声明(declaration)与定义(define)的区别，或者只是提到了需要支持分离式编译，使用&lt;code&gt;extern&lt;/code&gt; specifier的就是声明，不带的就是定义。实际上我觉得C++标准中对于声明(declaration)与定义(define)的区别描述的更为清晰。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>对象的构造和析构顺序</title>
    <link href="https://imzlp.com/posts/16550/"/>
    <id>https://imzlp.com/posts/16550/</id>
    <published>2017-02-19T18:04:24.000Z</published>
    <updated>2021-03-16T02:53:41.777Z</updated>
    
    
    <summary type="html">&lt;p&gt;通过一道CppQuiz的题来使用C++14标准描述C++的对象在继承情况下构造和析构的顺序，以及在对象构造/析构时抛出异常。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
    <category term="对象模型" scheme="https://imzlp.com/tags/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>重载(overload)和重写(override)</title>
    <link href="https://imzlp.com/posts/29726/"/>
    <id>https://imzlp.com/posts/29726/</id>
    <published>2017-02-06T05:08:43.000Z</published>
    <updated>2021-03-16T02:53:41.777Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++中&lt;code&gt;重载(overload)&lt;/code&gt;和&lt;code&gt;重写(override)&lt;/code&gt;并无关系，但是由于这个词比较相似还是容易搞混的。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux上的Samba配置</title>
    <link href="https://imzlp.com/posts/17347/"/>
    <id>https://imzlp.com/posts/17347/</id>
    <published>2017-02-04T05:29:47.000Z</published>
    <updated>2021-03-16T02:53:41.773Z</updated>
    
    
    <summary type="html">&lt;p&gt;通过Samba我们可以将Linux上的文件夹挂载到Windows上，开台Linux虚拟机部署Samba之后，在Windows就可以使用我前几天写的远程编译插件(&lt;a href=&quot;https://imzlp.com/posts/11793/&quot;&gt;sublimeRemoteCompile&lt;/a&gt;)来写代码啦！还是挺爽的。今天把服务器配置Samba共享文件的方法简单记录一下，方便有同样需求的朋友。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux环境" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
    <category term="Samba" scheme="https://imzlp.com/tags/Samba/"/>
    
  </entry>
  
  <entry>
    <title>工具、环境的知识收录</title>
    <link href="https://imzlp.com/posts/16793/"/>
    <id>https://imzlp.com/posts/16793/</id>
    <published>2017-02-03T23:39:14.000Z</published>
    <updated>2019-01-17T14:15:00.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;一些工具、环境配置的一些技巧或者相关的知识概念记录在这里。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="笔记" scheme="https://imzlp.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="notes" scheme="https://imzlp.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>SublimeText的远程编译插件</title>
    <link href="https://imzlp.com/posts/11793/"/>
    <id>https://imzlp.com/posts/11793/</id>
    <published>2017-01-25T01:43:55.000Z</published>
    <updated>2021-03-16T02:53:41.765Z</updated>
    
    
    <summary type="html">&lt;p&gt;经常在Win上写一些跑在Linux上的测试小代码还需要手动在Linux下执行编译命令有些麻烦，而且我用树莓派配置samba将代码共享到Win上也需要ssh上去手动编译，有点浪费时间。&lt;br&gt;这几天闲时写了一个SublimeText的小插件，用来在windows下远程编译C/C++的代码，就是在Windows上写代码但是实际会在Linux上执行。目前只是实现了功能，等放假后休息时有空优化一下。&lt;br&gt;代码放在Github上：&lt;a href=&quot;https://github.com/hxhb/sublimeRemoteCompile&quot;&gt;sublimeRemoteCompile&lt;/a&gt;，使用了一些&lt;code&gt;C++11&lt;/code&gt;的特性，编译时需指定。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="小项目" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="Sublime Text" scheme="https://imzlp.com/tags/Sublime-Text/"/>
    
    <category term="Code" scheme="https://imzlp.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>数组下标访问背后隐含的逻辑</title>
    <link href="https://imzlp.com/posts/20449/"/>
    <id>https://imzlp.com/posts/20449/</id>
    <published>2017-01-16T00:59:09.000Z</published>
    <updated>2021-03-16T02:53:41.765Z</updated>
    
    
    <summary type="html">&lt;p&gt;对于数组而言，下标运算是随机读写的一种方式，也是最常用的方式。但是有很多教材(尤其是国内教材)一上来就说数组名就是指针，这是不对的。而且对于数组的下标访问背后是有一套规则的，熟悉这些规则可以在一些复杂语义的情况下分析出代码的实际含义。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>裹一层重载的成员函数指针</title>
    <link href="https://imzlp.com/posts/19740/"/>
    <id>https://imzlp.com/posts/19740/</id>
    <published>2016-12-31T04:02:13.000Z</published>
    <updated>2017-05-15T16:27:14.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;使用变长参数模板和lambda(或者使用generic lambda)来裹一层重载的成员函数指针，从而方便使用(bind绑定或者其他需要重载的成员函数指针的地方)。&lt;br&gt;关于&lt;strong&gt;成员函数指针&lt;/strong&gt;的更多介绍请看我的另一篇文章：&lt;a href=&quot;https://imzlp.com/posts/27615&quot;&gt;C++中指向类成员的指针并非指针&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>The C++ Object and Memory Model</title>
    <link href="https://imzlp.com/posts/21843/"/>
    <id>https://imzlp.com/posts/21843/</id>
    <published>2016-12-15T21:11:24.000Z</published>
    <updated>2021-03-16T02:53:41.765Z</updated>
    
    
    <summary type="html">&lt;p&gt;More documentation:&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/memory_model&quot;&gt;Memory Model&lt;/a&gt; and &lt;a href=&quot;https://imzlp.com/2016/05/18/about-the-compiler-to-generate-the-default-constructor/&quot;&gt;Default Constructor Construction&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://imzlp.com/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>关于读书的一些思考</title>
    <link href="https://imzlp.com/posts/17446/"/>
    <id>https://imzlp.com/posts/17446/</id>
    <published>2016-12-11T20:43:42.000Z</published>
    <updated>2021-03-16T02:53:41.765Z</updated>
    
    
    <summary type="html">&lt;p&gt;如何对一门不熟悉的领域或者书籍划定其中最重要的20%？如何划定细枝末节？&lt;br&gt;之前读书和学习中没有深入思考过这些方法论的东西，觉得方法论只是空谈，但是现在觉得掌握一个合适的技巧如有利刃在手，披荆斩棘方可游刃有余。&lt;/p&gt;</summary>
    
    
    
    <category term="思想感悟" scheme="https://imzlp.com/categories/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="随笔" scheme="https://imzlp.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="方法论" scheme="https://imzlp.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>读TC++PL、C++Primer和ISO C++</title>
    <link href="https://imzlp.com/posts/4367/"/>
    <id>https://imzlp.com/posts/4367/</id>
    <published>2016-12-06T23:16:00.000Z</published>
    <updated>2021-03-16T02:53:41.761Z</updated>
    
    
    <summary type="html">&lt;p&gt;花了一个月的时间读完了TC++PL4E，因为我之前读过C++ Primer，C++大部分的语法内容都已了解，所以读的速度还是比较快的，但是通过组合阅读C++标准也发现了很多C++中我原本不知道的东西，从标准和C++之父的视角来看C++确实是足够全面了，由此来对比一下C++ Primer、TC++PL4E和ISO C++文档。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>What is POD in C++?</title>
    <link href="https://imzlp.com/posts/1140/"/>
    <id>https://imzlp.com/posts/1140/</id>
    <published>2016-12-03T00:04:28.000Z</published>
    <updated>2021-03-16T02:53:41.761Z</updated>
    
    
    <summary type="html">&lt;p&gt;POD is  Plain Old Data(普通旧数据).在C++中是指能被“仅当作数据”处理的对象，程序员无暇顾及类布局的复杂性以及用户自定义的构造、拷贝和移动语义。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>激进的ADL(Argument-dependent lookup)</title>
    <link href="https://imzlp.com/posts/25788/"/>
    <id>https://imzlp.com/posts/25788/</id>
    <published>2016-11-29T22:39:14.000Z</published>
    <updated>2021-03-16T02:53:41.761Z</updated>
    
    
    <summary type="html">&lt;p&gt;ADL是&lt;code&gt;Argument-dependent lookup&lt;/code&gt;的简写，中文译作参数依赖查找。ADL对于避免冗长的代码很有用处，但是也会造成一些歧义。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>TC++PL4E中英版勘误</title>
    <link href="https://imzlp.com/posts/409/"/>
    <id>https://imzlp.com/posts/409/</id>
    <published>2016-11-20T21:46:53.000Z</published>
    <updated>2021-03-16T02:53:41.761Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近在读The C++ Programming Language Fourth Edition(简称TC++PL4E)，由于我入的实体书是中译本(原版好贵)，所以我是对照着英文版PDF看的，发现了一些原版和中译本中的勘误，还有一些我觉得书中歧义的地方，查阅标准(ISO/IEC 14882:2014(E))之后的定义也一并贴出，汇总在这里列出来。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="勘误表" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8B%98%E8%AF%AF%E8%A1%A8/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="勘误表" scheme="https://imzlp.com/tags/%E5%8B%98%E8%AF%AF%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C/C++标准的一些摘录</title>
    <link href="https://imzlp.com/posts/19242/"/>
    <id>https://imzlp.com/posts/19242/</id>
    <published>2016-11-12T01:19:51.000Z</published>
    <updated>2017-04-05T15:19:57.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;C/C++的很多资料网上数不胜数，但是经常会遇到看了一些文章资料后，我觉得作者自己都没彻底明白到底写的是什么(回头看看我以前写的文章也是，那时的眼光太片面和浅显了)。&lt;br&gt;所以对于C/C++的东西我觉得还是要直接来翻标准文档才行，因为标准是不会出现歧义的。不能盲目地只是在网上搜寻并相信别人二次消化过的资料。&lt;br&gt;我认为对于C/C++语言特性的知识，查阅这四份文档就足够了(点击即可在线预览或下载)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://doc.imzlp.com/viewer.html?file=docs/standard/isoc99.pdf&quot;&gt;ISO/IEC 9899:1999 (E)&lt;/a&gt; (C99标准)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://doc.imzlp.com/viewer.html?file=docs/clang/TCPL2E.pdf&quot;&gt;The C Programming language Second Edition&lt;/a&gt; (C语言之父Dennis Ritchie和Brian Kernighan的大作)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://doc.imzlp.com/viewer.html?file=docs/standard/isocpp2014.pdf&quot;&gt;ISO/IEC 14882:2014(E)&lt;/a&gt; (C++14标准)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://doc.imzlp.com/viewer.html?file=docs/cpp/TCPPPL4E.pdf&quot;&gt;The C++ Programming Language Fourth Edition&lt;/a&gt; (C++之父撰写，依据C++11标准)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之所以C语言标准没有依据最新的C11标准是因为目前的C++标准(C++14)的&lt;code&gt;Normative references&lt;/code&gt;的C部分是&lt;strong&gt;ISO/IEC 9899:1999&lt;/strong&gt;，使用TCPL和TC++PL可以作为C/C++标准的应用性描述，可以相互印证。&lt;br&gt;更多的关于C++&lt;code&gt;Normative references&lt;/code&gt;的内容可参照&lt;a href=&quot;https://o66j3dueo.qnssl.com/Document/ISOIEC.14882.2014%28C++14%29.pdf&quot;&gt;ISO/IEC 14882:2014(E)&lt;/a&gt; §1.2 Normative references.&lt;br&gt;我会逐渐把一些常见的会让人觉得模棱两可的语言特性查阅的标准规范摘录到这里来，可以保证写出的东西在标准文档中都有依据。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C++标准" scheme="https://imzlp.com/tags/C-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>CppQuiz一些有趣的题和分析</title>
    <link href="https://imzlp.com/posts/10205/"/>
    <id>https://imzlp.com/posts/10205/</id>
    <published>2016-10-24T06:15:05.000Z</published>
    <updated>2021-03-16T02:53:41.757Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://cppquiz.org/&quot;&gt;CppQuiz&lt;/a&gt; is a simple online quiz that you can use to test your knowledge of the C++ programming language.&lt;br&gt;很有意思，今天刷了几道随手写点东西出来，以后有空再刷刷都放到这里来好了。其实CppQuiz有很多题都可以从《深度探索C++对象模型》中找到原因…如果有很多题不会做我建议还是买一本《深度探索C++对象模型》认真看一遍吧！&lt;br&gt;另外，我尽量在解答题的同时会在C++标准(ISO/IEC 14882：2014)中找到相关的描述。&lt;/p&gt;</summary>
    
    
    
    <category term="代码分析" scheme="https://imzlp.com/categories/%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="Code" scheme="https://imzlp.com/tags/Code/"/>
    
    <category term="CppQuiz" scheme="https://imzlp.com/tags/CppQuiz/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis CI自动部署Github/Coding Pages博客</title>
    <link href="https://imzlp.com/posts/42318/"/>
    <id>https://imzlp.com/posts/42318/</id>
    <published>2016-10-21T06:36:49.000Z</published>
    <updated>2021-03-16T02:53:41.753Z</updated>
    
    
    <summary type="html">&lt;p&gt;使用Hexo生成静态博客然后部署到Github/Coding Pages是目前我的博客的托管方式。&lt;br&gt;用起来是很爽，但是存在几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hexo的环境配置太麻烦，麻烦到几乎换台电脑就不能更新博客了&lt;/li&gt;
&lt;li&gt;每次修改文章之后都要重新生成一遍&lt;/li&gt;
&lt;li&gt;再加上提交博客源文件的话执行命令的次数太多了(主要是第一步)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在提交博文的时候浪费了很多时间，我优化了一下流程几乎可以全自动提交更新了。&lt;/p&gt;</summary>
    
    
    
    <category term="博客管理" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/Hexo/"/>
    
    
    <category term="Github" scheme="https://imzlp.com/tags/Github/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/tags/Hexo/"/>
    
    <category term="工具集锦" scheme="https://imzlp.com/tags/%E5%B7%A5%E5%85%B7%E9%9B%86%E9%94%A6/"/>
    
    <category term="持续集成" scheme="https://imzlp.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Boost源码分析笔记</title>
    <link href="https://imzlp.com/posts/18194/"/>
    <id>https://imzlp.com/posts/18194/</id>
    <published>2016-10-19T21:39:33.000Z</published>
    <updated>2021-03-16T02:53:41.753Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近在读Boost的代码，将一些Boost库中好用的模块用法以及实现分析写一下咯，不定期更新。&lt;/p&gt;</summary>
    
    
    
    <category term="编程笔记" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Boost" scheme="https://imzlp.com/tags/Boost/"/>
    
  </entry>
  
  <entry>
    <title>配置SublimeText为Boost开发环境</title>
    <link href="https://imzlp.com/posts/49268/"/>
    <id>https://imzlp.com/posts/49268/</id>
    <published>2016-10-13T09:24:16.000Z</published>
    <updated>2021-03-16T02:53:41.753Z</updated>
    
    
    <summary type="html">&lt;p&gt;近期想研究下&lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt;库，网络上提供的大都是使用IDE(VS/Code::Blocks等)的教程，但是只是写一些测试代码就要开个臃肿的IDE我是很不爽的，今天折腾了一下在SublimeText中编译/链接使用Boost库的代码。顺便把折腾过程/工具整理了出来，如果别人有这样的需求而且恰好能看到这篇文章的话，就能少浪费时间了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2016.11.01 Update&lt;/strong&gt;&lt;br&gt;使用最新版本MinGW64-GCC6.2(x86_64-6.2.0-posix-seh-rt_v5-rev1)来编译出LLVM/Clang 3.9，再使用编译出来的Clang编译Boost1.62，之前在Clang中链接编译出来的Boost库出现的报错情况消失了。&lt;br&gt;&lt;strong&gt;注意：使用Clang编译Boost时，最好确保当前的clang版本是由当前系统中gcc的版本编译而来的，不然使用clang链接编译出来的静态链接库时会出现奇怪的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在这里下载我编译好的版本：&lt;a href=&quot;http://pan.baidu.com/s/1i5PpoB7&quot;&gt;MinGW62-GCC6.2(x86_64-6.2.0-posix-seh-rt_v5-rev1)&lt;/a&gt;，使用GCC6.2(上面的MinGW版本)编译的&lt;a href=&quot;http://pan.baidu.com/s/1pKLyZ7H&quot;&gt;LLVM/Clang3.9&lt;/a&gt;，以及&lt;a href=&quot;http://pan.baidu.com/s/1eRZU26u&quot;&gt;Boost(MinGW64-GCC6.2/LLVM3.9/VC14-ALL)&lt;/a&gt;，需要的链接库版本(debug/release/static等)可以自行选择。&lt;br&gt;完整的编译工具链可以&lt;a href=&quot;http://pan.baidu.com/s/1pKN0TPh&quot;&gt;点此下载&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="SublimeText" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/SublimeText/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="Sublime Text" scheme="https://imzlp.com/tags/Sublime-Text/"/>
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Boost" scheme="https://imzlp.com/tags/Boost/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker部署shadowsocks服务</title>
    <link href="https://imzlp.com/posts/354/"/>
    <id>https://imzlp.com/posts/354/</id>
    <published>2016-10-10T22:10:01.000Z</published>
    <updated>2021-03-16T02:53:41.749Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://app.arukas.io/&quot;&gt;Arukas&lt;/a&gt;是日本的一家&lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt;服务供应商，目前属于测试阶段，可以免费使用。我们可以用&lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt;很方便的来做一些很有趣(好用)的事，比如部署自己的博客或者shadowsocks服务器。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://imzlp.com/categories/Docker/"/>
    
    
    <category term="Shadowsocks" scheme="https://imzlp.com/tags/Shadowsocks/"/>
    
    <category term="Docker" scheme="https://imzlp.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在UE中使用Git进行版本控制</title>
    <link href="https://imzlp.com/posts/7647/"/>
    <id>https://imzlp.com/posts/7647/</id>
    <published>2016-10-07T23:31:01.000Z</published>
    <updated>2021-03-16T02:53:41.741Z</updated>
    
    
    <summary type="html">&lt;p&gt;Unreal Editor中提供的Source Control可以通过Git实现蓝图项目的&lt;strong&gt;版本提交/版本比对/撤销修改&lt;/strong&gt;等一些基本功能，远远比不上Git Bash强大，但是BluePrint间的Diff还是很好用的。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    <category term="Git" scheme="https://imzlp.com/categories/Unreal-Engine/Git/"/>
    
    
    <category term="Git" scheme="https://imzlp.com/tags/Git/"/>
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Source Control" scheme="https://imzlp.com/tags/Source-Control/"/>
    
    <category term="版本控制" scheme="https://imzlp.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Git快速上手指南</title>
    <link href="https://imzlp.com/posts/53696/"/>
    <id>https://imzlp.com/posts/53696/</id>
    <published>2016-09-29T22:19:37.000Z</published>
    <updated>2018-08-15T00:57:19.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;我司最近搭建了内网服务器，以后再做项目时都要用git来进行版本控制了，我在这里把一些常用的操作写下来方便查阅。&lt;/p&gt;</summary>
    
    
    
    <category term="版本控制" scheme="https://imzlp.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    <category term="Git" scheme="https://imzlp.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
    
    
    <category term="Git" scheme="https://imzlp.com/tags/Git/"/>
    
    <category term="Source Control" scheme="https://imzlp.com/tags/Source-Control/"/>
    
    <category term="版本控制" scheme="https://imzlp.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>为C++的switch添加case的字符串匹配</title>
    <link href="https://imzlp.com/posts/1494/"/>
    <id>https://imzlp.com/posts/1494/</id>
    <published>2016-09-24T22:43:23.000Z</published>
    <updated>2021-03-16T02:53:41.737Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++标准中的&lt;code&gt;switch&lt;/code&gt;是不能够实现字符串的case匹配的，但是往往我们也有这个需求，来实现一下。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>总结一下编码的几个习惯</title>
    <link href="https://imzlp.com/posts/35673/"/>
    <id>https://imzlp.com/posts/35673/</id>
    <published>2016-09-13T07:26:09.000Z</published>
    <updated>2021-03-16T02:53:41.737Z</updated>
    
    
    <summary type="html">&lt;p&gt;最开始写代码的时候总是拿到一个问题就捋起袖子开干，基本上就是属于边写代码边排错顺便在写代码中设计解决问题的流程，但是这样效率实在是太慢，有很大的可能就是边写边删，等同于设计出来的蹩脚的就重构了，浪费了很多时间。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>读《C++语言的设计与演化》及一些疑问的解答</title>
    <link href="https://imzlp.com/posts/30227/"/>
    <id>https://imzlp.com/posts/30227/</id>
    <published>2016-09-09T08:15:46.000Z</published>
    <updated>2021-03-16T02:53:41.737Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1096216/&quot;&gt;C++语言的设计与演化&lt;/a&gt;是C++作者Bjarne Stroustrup撰写的一本关于C++从构思设计到实际实现中思考权衡的过程的书，也(应该)是市面上唯一一本语言设计者站在&lt;strong&gt;语言设计&lt;/strong&gt;的视角所写的书。&lt;/p&gt;
&lt;p&gt;有很多问题我们不应该只知道&lt;strong&gt;How&lt;/strong&gt;，更应该知道&lt;strong&gt;Why&lt;/strong&gt;，因为这样可以从更深层次地理解这个东西。所幸的是《C++语言的设计与演化》就是这么一本书。最近在读期间明白了很多之前在C++中只知道&lt;strong&gt;How&lt;/strong&gt;而不知道&lt;strong&gt;Why&lt;/strong&gt;的东西(为了与C兼容C++真是割舍了太多)，这篇文章算是一篇读书笔记和关于&lt;strong&gt;Why&lt;/strong&gt;的记录，我会逐步整理出来。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用Unreal Engine 4采集360°全景视频</title>
    <link href="https://imzlp.com/posts/64044/"/>
    <id>https://imzlp.com/posts/64044/</id>
    <published>2016-09-05T19:44:11.000Z</published>
    <updated>2021-03-16T02:53:41.737Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文部分内容摘自Unreal Engine的官方博客文章：&lt;a href=&quot;https://www.unrealengine.com/zh-CN/blog/capturing-stereoscopic-360-screenshots-videos-movies-unreal-engine-4&quot;&gt;从虚幻4中采集360度立体电影&lt;/a&gt;，其余部分为修正该文章错误和提供一个现成可行的解决方案。&lt;/p&gt;</summary>
    
    
    
    <category term="Unreal Engine" scheme="https://imzlp.com/categories/Unreal-Engine/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="Unreal Engine" scheme="https://imzlp.com/tags/Unreal-Engine/"/>
    
    <category term="Code" scheme="https://imzlp.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>读CSAPP：与《现代操作系统》的比较</title>
    <link href="https://imzlp.com/posts/33213/"/>
    <id>https://imzlp.com/posts/33213/</id>
    <published>2016-08-30T01:32:15.000Z</published>
    <updated>2021-03-16T02:53:41.737Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天读&lt;strong&gt;CSAPP&lt;/strong&gt;读的兴起，昨天还发了条动态说读&lt;strong&gt;CSAPP&lt;/strong&gt;比&lt;strong&gt;现代操作系统&lt;/strong&gt;读着爽(哈哈)。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>动态内存和智能指针</title>
    <link href="https://imzlp.com/posts/4280/"/>
    <id>https://imzlp.com/posts/4280/</id>
    <published>2016-08-25T08:18:53.000Z</published>
    <updated>2021-03-16T02:53:41.737Z</updated>
    
    
    <summary type="html">&lt;p&gt;智能指针作为C++11最重要的特性之一，相关的内容本来是辑录在&lt;a href=&quot;https://imzlp.com/2016/05/12/cpp11-new-features/&quot;&gt;C++11的语法糖&lt;/a&gt;中，但是这部分太重要而我最近又比较闲(逃)，就单独列出来详细地总结一下咯。&lt;/p&gt;</summary>
    
    
    
    <category term="编程笔记" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Source Insight插件与配置</title>
    <link href="https://imzlp.com/posts/42068/"/>
    <id>https://imzlp.com/posts/42068/</id>
    <published>2016-08-14T08:08:31.000Z</published>
    <updated>2021-03-16T02:53:41.733Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近折腾上了几款开发相关的工具堪称神器，工欲善其事必先利其器也。有时间来整理一下写出来。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="code review" scheme="https://imzlp.com/tags/code-review/"/>
    
  </entry>
  
  <entry>
    <title>使用VisualGDB在VS上编写Linux程序</title>
    <link href="https://imzlp.com/posts/9932/"/>
    <id>https://imzlp.com/posts/9932/</id>
    <published>2016-08-08T00:53:42.000Z</published>
    <updated>2021-03-16T02:53:41.721Z</updated>
    
    
    <summary type="html">&lt;p&gt;作为一个cpper和Linuxer，经常在Linux上写代码，最近发现了VisualGDB(VS的插件)这个神器，从此也可以在Windows上直接写跑在Linux的程序了！调试起来更爽！&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="VisualGDB" scheme="https://imzlp.com/tags/VisualGDB/"/>
    
    <category term="VisualStudio" scheme="https://imzlp.com/tags/VisualStudio/"/>
    
  </entry>
  
  <entry>
    <title>在VPS上部署shadowsocks服务</title>
    <link href="https://imzlp.com/posts/31145/"/>
    <id>https://imzlp.com/posts/31145/</id>
    <published>2016-07-27T20:34:32.000Z</published>
    <updated>2021-03-16T02:53:41.721Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天帮同事搭了一台用作代理的VPS，顺道把这些东西整理了一下。&lt;br&gt;本文不是面向零基础读者的，在阅读下面的东西之前，你首先应该有一台可以访问外网(国外网络)的VPS，其次你也应该具有一些基本的Linux操作的知识。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux环境" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/"/>
    
    <category term="Shadowsocks" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/Shadowsocks/"/>
    
    
    <category term="Shadowsocks" scheme="https://imzlp.com/tags/Shadowsocks/"/>
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
    <category term="VPS" scheme="https://imzlp.com/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>学习C/C++的一些书籍和工具</title>
    <link href="https://imzlp.com/posts/64054/"/>
    <id>https://imzlp.com/posts/64054/</id>
    <published>2016-06-12T12:08:43.000Z</published>
    <updated>2021-03-16T02:53:41.709Z</updated>
    
    
    <summary type="html">&lt;p&gt;从开始学C语言到现在也有五六年的时间了，也看了不少的好书和烂书，折腾了很多工具(编译器/编辑器圣战)，在这里详细汇总一下。折腾久了能够得到一种思想，这种思想不同于那种“拿来主义”，而是“自己去做”的经验。&lt;/p&gt;</summary>
    
    
    
    <category term="资源分享" scheme="https://imzlp.com/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>未来计划</title>
    <link href="https://imzlp.com/posts/52122/"/>
    <id>https://imzlp.com/posts/52122/</id>
    <published>2016-06-10T09:52:32.000Z</published>
    <updated>2021-03-16T02:53:41.705Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;img data-src=&quot;https://imzlp.com/posts/52122/future-plans.webp&quot;&gt;&lt;br&gt;转眼大学即将毕业了，虽然大学期间学了(折腾)了不少东西，但是还是觉得很菜啊，还要继续努力。&lt;br&gt;对于未来我有几点想法，在这个当口写下来吧。督促勉励自己。&lt;/p&gt;</summary>
    
    
    
    <category term="思想感悟" scheme="https://imzlp.com/categories/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="思想感悟" scheme="https://imzlp.com/tags/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>谈高考</title>
    <link href="https://imzlp.com/posts/27665/"/>
    <id>https://imzlp.com/posts/27665/</id>
    <published>2016-06-08T07:44:11.000Z</published>
    <updated>2021-03-16T02:53:41.705Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天是高考的时间，想到了几年之前我参加高考的时候，那个时候还是too young，觉得有自己追求的东西就要去做，浪费了很多时间在学习编程上。可是现在看来高中的时候还是要好好学习的，因为学历就刚毕业而言确实是门槛。&lt;/p&gt;</summary>
    
    
    
    <category term="思想感悟" scheme="https://imzlp.com/categories/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="思想感悟" scheme="https://imzlp.com/tags/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Pthread多线程编程</title>
    <link href="https://imzlp.com/posts/58408/"/>
    <id>https://imzlp.com/posts/58408/</id>
    <published>2016-06-04T17:08:48.000Z</published>
    <updated>2021-03-16T02:53:41.705Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B&quot;&gt;POSIX线程&lt;/a&gt;（英语：POSIX Threads，常被缩写为Pthreads）是POSIX的线程标准，定义了创建和操纵线程的一套API。&lt;/p&gt;</summary>
    
    
    
    <category term="UNIX" scheme="https://imzlp.com/categories/UNIX/"/>
    
    <category term="POSIX" scheme="https://imzlp.com/categories/UNIX/POSIX/"/>
    
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="多线程" scheme="https://imzlp.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Pthread" scheme="https://imzlp.com/tags/Pthread/"/>
    
  </entry>
  
  <entry>
    <title>删除void*指针引发的内存泄露</title>
    <link href="https://imzlp.com/posts/6978/"/>
    <id>https://imzlp.com/posts/6978/</id>
    <published>2016-06-04T10:51:47.000Z</published>
    <updated>2021-03-16T02:53:41.705Z</updated>
    
    
    <summary type="html">&lt;p&gt;当一个void*指向一个class object时，我们对其执行&lt;code&gt;delete&lt;/code&gt;操作，会引发未定义行为——可以确定的是该delete操作不会执行object的析构函数，会导致内存泄露。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>结构体成员内存对齐问题</title>
    <link href="https://imzlp.com/posts/61962/"/>
    <id>https://imzlp.com/posts/61962/</id>
    <published>2016-06-02T10:12:34.000Z</published>
    <updated>2021-03-16T02:53:41.705Z</updated>
    
    
    <summary type="html">&lt;p&gt;在讲内存对齐之前，先介绍一个相关的概念——&lt;a href=&quot;http://www.baike.com/wiki/%E5%81%8F%E7%A7%BB%E9%87%8F&amp;prd=so_1_doc&quot;&gt;偏移量&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把存储单元的实际地址与其所在段的段地址之间的距离称为段内偏移，也称为“有效地址或偏移量”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，在结构体中偏移量指的是结构体变量中成员的地址和结构体地址的差。&lt;/p&gt;</summary>
    
    
    
    <category term="编程笔记" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C语言中不具有原生bool类型</title>
    <link href="https://imzlp.com/posts/20582/"/>
    <id>https://imzlp.com/posts/20582/</id>
    <published>2016-06-01T19:46:55.000Z</published>
    <updated>2021-03-16T02:53:41.705Z</updated>
    
    
    <summary type="html">&lt;p&gt;有点标题党了，准确的说是C语言标准中并无&lt;code&gt;bool&lt;/code&gt;这个关键字来表示布尔类型。&lt;br&gt;在C++中我们通常使用&lt;code&gt;bool&lt;/code&gt;变量存储逻辑值。&lt;br&gt;但是，C语言中是没有&lt;code&gt;bool&lt;/code&gt;类型的，C语言中只有&lt;code&gt;_Bool&lt;/code&gt;类型。&lt;br&gt;今天和人聊到这个问题，确实容易搞混淆，写出来记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="标准解读" scheme="https://imzlp.com/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    
    <category term="标准解读" scheme="https://imzlp.com/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="C语言标准" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>将树莓派打造成便携的Linux编译环境</title>
    <link href="https://imzlp.com/posts/15989/"/>
    <id>https://imzlp.com/posts/15989/</id>
    <published>2016-05-25T09:04:52.000Z</published>
    <updated>2021-03-16T02:53:41.697Z</updated>
    
    
    <summary type="html">&lt;p&gt;手头有块Rspberry 2B+，吃灰挺长时间了，由于一直在学校老是停电也就没拿它来跑脚本或者下载机。也正是因为最近学校SSH连接VPS的时候老是断电/网，很郁闷，所以折腾一下把树莓派搞成一个便携的编译环境。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux环境" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="树莓派" scheme="https://imzlp.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>关于编译器生成默认构造函数的一些误区</title>
    <link href="https://imzlp.com/posts/7666/"/>
    <id>https://imzlp.com/posts/7666/</id>
    <published>2016-05-18T19:38:50.000Z</published>
    <updated>2021-03-16T02:53:41.693Z</updated>
    
    
    <summary type="html">&lt;p&gt;当我们编写的一个类没有显式提供构造函数但&lt;code&gt;编译器需要构造函数时&lt;/code&gt;(一定要注意这句话)，编译器会为我们生成一个。&lt;br&gt;但是编译器生成的默认构造函数与我们假想其可以完成的行为并不一致。&lt;/p&gt;</summary>
    
    
    
    <category term="编程笔记" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++对象模型" scheme="https://imzlp.com/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信</title>
    <link href="https://imzlp.com/posts/58483/"/>
    <id>https://imzlp.com/posts/58483/</id>
    <published>2016-05-17T19:48:04.000Z</published>
    <updated>2021-03-16T02:53:41.693Z</updated>
    
    
    <summary type="html">&lt;p&gt;实现进程/线程间通信的方法有:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程间通信方法有：文件映射、共享内存、匿名管道、命名管道、邮件槽、剪切板、动态数据交换、对象连接与嵌入、动态连接库、远程过程调用等&lt;/li&gt;
&lt;li&gt;进程间通信方法有：文件映射、共享内存、匿名管道、命名管道、邮件槽、剪切板、动态数据交换、对象连接与嵌入、动态连接库、远程过程调用等&lt;/li&gt;
&lt;li&gt;线程同步的方法有：事件、临界区、互斥量、信号量&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="进程间通信" scheme="https://imzlp.com/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
    <category term="操作系统" scheme="https://imzlp.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++11的语法糖</title>
    <link href="https://imzlp.com/posts/2441/"/>
    <id>https://imzlp.com/posts/2441/</id>
    <published>2016-05-12T22:30:19.000Z</published>
    <updated>2021-03-16T02:53:41.689Z</updated>
    
    
    <summary type="html">&lt;p&gt;从C语言过来觉得C++03和OO的特性简直不能更爽，最近着重看了一下C++11的新特性，觉得有好多很棒的语法糖啊！用起来也很爽啊。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="C++11" scheme="https://imzlp.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>STL释放指针元素时造成的内存泄露</title>
    <link href="https://imzlp.com/posts/50773/"/>
    <id>https://imzlp.com/posts/50773/</id>
    <published>2016-05-08T13:51:13.000Z</published>
    <updated>2021-03-16T02:53:41.689Z</updated>
    
    
    <summary type="html">&lt;p&gt;当我们删除一个指针时，会删除该指针所指向的对象。但是当STL容器中存放指针对象时却不会这样。&lt;/p&gt;</summary>
    
    
    
    <category term="编程笔记" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程笔记" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用Gprof分析代码性能瓶颈</title>
    <link href="https://imzlp.com/posts/34573/"/>
    <id>https://imzlp.com/posts/34573/</id>
    <published>2016-05-07T13:32:34.000Z</published>
    <updated>2021-03-16T02:53:41.685Z</updated>
    
    
    <summary type="html">&lt;p&gt;使用&lt;strong&gt;profiler&lt;/strong&gt;来分析代码的性能比纯脑补分析起来更省力更详细也更直观。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Profiler" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Profiler/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="C语言" scheme="https://imzlp.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Gprof" scheme="https://imzlp.com/tags/Gprof/"/>
    
    <category term="Profiler" scheme="https://imzlp.com/tags/Profiler/"/>
    
  </entry>
  
  <entry>
    <title>详细分析下C++中的类型转换</title>
    <link href="https://imzlp.com/posts/27258/"/>
    <id>https://imzlp.com/posts/27258/</id>
    <published>2016-05-04T19:35:17.000Z</published>
    <updated>2021-03-16T02:53:41.685Z</updated>
    
    
    <summary type="html">&lt;p&gt;在C++中，如果一个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型。&lt;br&gt;类型转换分为&lt;strong&gt;隐式转换&lt;/strong&gt;、和&lt;strong&gt;显式转换&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++中面向对象部分知识整理</title>
    <link href="https://imzlp.com/posts/34569/"/>
    <id>https://imzlp.com/posts/34569/</id>
    <published>2016-04-16T17:31:49.000Z</published>
    <updated>2021-03-16T02:53:41.685Z</updated>
    
    
    <summary type="html">&lt;p&gt;近期准备求职面试。&lt;br&gt;将C++中面向对象部分的基础知识复习整理一下。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>选择操作符重载的成员和非成员实现</title>
    <link href="https://imzlp.com/posts/34001/"/>
    <id>https://imzlp.com/posts/34001/</id>
    <published>2016-03-21T16:54:58.000Z</published>
    <updated>2021-03-16T02:53:41.685Z</updated>
    
    
    <summary type="html">&lt;p&gt;为类设计重载操作符的时候，必须选择是将操作符设置为类成员还是普通非成员函数。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读《人生》，谈谈面临的选择</title>
    <link href="https://imzlp.com/posts/54010/"/>
    <id>https://imzlp.com/posts/54010/</id>
    <published>2016-03-20T14:07:26.000Z</published>
    <updated>2021-03-16T02:53:41.685Z</updated>
    
    
    <summary type="html">这是一篇加密文章，请输入密码后阅读。</summary>
    
    
    
    <category term="思想感悟" scheme="https://imzlp.com/categories/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="思想感悟" scheme="https://imzlp.com/tags/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中占位修饰符*的用法</title>
    <link href="https://imzlp.com/posts/16506/"/>
    <id>https://imzlp.com/posts/16506/</id>
    <published>2016-03-19T11:49:16.000Z</published>
    <updated>2021-03-16T02:53:41.685Z</updated>
    
    
    <summary type="html">&lt;p&gt;在刷题的时候碰到的代码填空看到输出格式中的这段代码：&lt;code&gt;printf(&amp;quot;%*s%s%*s\n&amp;quot;,__________);&lt;/code&gt;&lt;br&gt;需要输出的格式为：&lt;code&gt;________123456________&lt;/code&gt;//下划线为空格&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++中错用宏定义造成的二义性</title>
    <link href="https://imzlp.com/posts/38656/"/>
    <id>https://imzlp.com/posts/38656/</id>
    <published>2016-03-14T19:07:46.000Z</published>
    <updated>2021-03-16T02:53:41.685Z</updated>
    
    
    <summary type="html">&lt;p&gt;在写代码的时候经常会用到宏(#define)命令，最近我遇到了这两个错用宏的地方，写出来分析一下。&lt;/p&gt;</summary>
    
    
    
    <category term="编程技巧" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="编程技巧" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>配置SublimeText为C/C++的轻量级IDE</title>
    <link href="https://imzlp.com/posts/14596/"/>
    <id>https://imzlp.com/posts/14596/</id>
    <published>2015-12-26T21:54:01.000Z</published>
    <updated>2017-04-10T18:18:34.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;作为一个cpper，其实早就用惯了GCC这样的工具，不过不得不说啊，GCC的错误信息是真烂啊，虽然有错误提示，但是也经常需要自己肉眼Debug才能搞明白…现在福音来了，&lt;code&gt;Clang&lt;/code&gt;的信息精准度不知道比GCC高到哪里去了。&lt;/p&gt;</summary>
    
    
    
    <category term="编程工具" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="SublimeText" scheme="https://imzlp.com/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/SublimeText/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="Sublime Text" scheme="https://imzlp.com/tags/Sublime-Text/"/>
    
    <category term="Clang" scheme="https://imzlp.com/tags/Clang/"/>
    
    <category term="编程工具" scheme="https://imzlp.com/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用Wolfram|Alpha求积分</title>
    <link href="https://imzlp.com/posts/8531/"/>
    <id>https://imzlp.com/posts/8531/</id>
    <published>2015-12-24T20:52:35.000Z</published>
    <updated>2021-03-16T02:53:41.677Z</updated>
    
    
    <summary type="html">&lt;p&gt;其实使用&lt;a href=&quot;http://www.wolframalpha.com/&quot;&gt;WolframAlpha&lt;/a&gt;求积分，简直就是大材小用啊(不过这也是硬性的偷懒需求啊)。&lt;br&gt;最近一直在研究Wolfram Language，慢慢发掘新玩法咯。&lt;/p&gt;</summary>
    
    
    
    <category term="网络工具" scheme="https://imzlp.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具集锦" scheme="https://imzlp.com/tags/%E5%B7%A5%E5%85%B7%E9%9B%86%E9%94%A6/"/>
    
    <category term="Wolfram|Alpha" scheme="https://imzlp.com/tags/Wolfram-Alpha/"/>
    
    <category term="数学" scheme="https://imzlp.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用Koding在线管理静态博客</title>
    <link href="https://imzlp.com/posts/58862/"/>
    <id>https://imzlp.com/posts/58862/</id>
    <published>2015-11-27T13:16:33.000Z</published>
    <updated>2021-03-16T02:53:41.673Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前都是在local写完文章之后发布上来，在自己电脑上都折腾好了node.js 、hexo、git等一大堆东西。&lt;br&gt;所以在自己电脑上用起来很方便，但是如果换台电脑的话就悲剧了，所有的东西都要自己配置，所以几乎换了台电脑就处于不能用的状态。&lt;/p&gt;</summary>
    
    
    
    <category term="博客管理" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://imzlp.com/tags/Hexo/"/>
    
    <category term="Koding" scheme="https://imzlp.com/tags/Koding/"/>
    
  </entry>
  
  <entry>
    <title>读《数学之美》</title>
    <link href="https://imzlp.com/posts/19425/"/>
    <id>https://imzlp.com/posts/19425/</id>
    <published>2015-10-24T18:22:02.000Z</published>
    <updated>2021-03-16T02:53:41.673Z</updated>
    
    
    <summary type="html">&lt;p&gt;到手《数学之美》也有一段的时间了，作为这段时间内我茶余饭后的书籍，确实引起了我极大的兴趣，因为时间分配的不多一天只有阅读一两章左右，昨天看完了所有的章节，意犹未尽啊。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数学之美" scheme="https://imzlp.com/tags/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>分析密码学中的数学原理</title>
    <link href="https://imzlp.com/posts/30891/"/>
    <id>https://imzlp.com/posts/30891/</id>
    <published>2015-09-09T18:19:26.000Z</published>
    <updated>2021-03-16T02:53:41.673Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天看到《数学之美》中讲到的计算机中的数学模型，以及《What is Mathematics》的&lt;code&gt;数论&lt;/code&gt;，看的心痒痒。今天懒癌暂时被抑制住了，我就要分析一下，密码学中的数学模型！&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="https://imzlp.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="密码学" scheme="https://imzlp.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux下使用Shadowsocks服务</title>
    <link href="https://imzlp.com/posts/23429/"/>
    <id>https://imzlp.com/posts/23429/</id>
    <published>2015-08-26T17:31:57.000Z</published>
    <updated>2021-03-16T02:53:41.669Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天重装了Linux，又不想再用GUI的SS，网上的资料都不怎么好用，自己动手折腾了一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux环境" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/"/>
    
    <category term="Shadowsocks" scheme="https://imzlp.com/categories/Linux%E7%8E%AF%E5%A2%83/Shadowsocks/"/>
    
    
    <category term="Shadowsocks" scheme="https://imzlp.com/tags/Shadowsocks/"/>
    
    <category term="Linux" scheme="https://imzlp.com/tags/Linux/"/>
    
    <category term="UNIX" scheme="https://imzlp.com/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>提取优酷订阅视频的RSS源</title>
    <link href="https://imzlp.com/posts/23354/"/>
    <id>https://imzlp.com/posts/23354/</id>
    <published>2015-08-19T14:56:12.000Z</published>
    <updated>2021-03-16T02:53:41.661Z</updated>
    
    
    <summary type="html">&lt;p&gt;这两天在折腾RSS，收集了不少RSS源，对于我等懒人来说，不开网页尽知消息RSS才是真正的利器，这两天搞定了QQ空间的RSS输出（没什么实用性…）还有新浪微博和新浪博客的RSS输出，但是我还比较喜欢的逻辑思维（在优酷），优酷并不提供RSS订阅，目前网内还没有发现什么特别有效的提取优酷订阅RSS源的方法，各种在线转换的网站基本没用，这等还要打开网页才能干的麻烦不能忍，所以动手研究了一下怎么把优酷订阅搞成RSS源，成功了，非常爽。&lt;/p&gt;</summary>
    
    
    
    <category term="网络工具" scheme="https://imzlp.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="RSS" scheme="https://imzlp.com/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>Windows下自定义Dvorak键盘布局</title>
    <link href="https://imzlp.com/posts/50343/"/>
    <id>https://imzlp.com/posts/50343/</id>
    <published>2015-08-19T11:01:32.000Z</published>
    <updated>2021-03-16T02:53:41.665Z</updated>
    
    
    <summary type="html">&lt;p&gt;几经波折总算是搞定了windows下的Dvorak布局（不过稍有修改）&lt;br&gt;先从Dvorak的布局图开始说吧&lt;br&gt;&lt;img data-src=&quot;https://imzlp.com/posts/50343/dvorakpsb.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="折腾记录" scheme="https://imzlp.com/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="工具集锦" scheme="https://imzlp.com/tags/%E5%B7%A5%E5%85%B7%E9%9B%86%E9%94%A6/"/>
    
    <category term="Dvorak" scheme="https://imzlp.com/tags/Dvorak/"/>
    
  </entry>
  
  <entry>
    <title>Chrome插件推荐</title>
    <link href="https://imzlp.com/posts/841/"/>
    <id>https://imzlp.com/posts/841/</id>
    <published>2015-08-18T14:50:26.000Z</published>
    <updated>2021-03-16T02:53:41.653Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;LastPass&lt;/code&gt;: Free Password Manager&lt;br&gt;强大的密码管理器，从此以后只记住一个密码就好了。&lt;br&gt;&lt;code&gt;Momentum&lt;/code&gt;&lt;br&gt;论如何优雅的使用Chorme，每天一张好看的壁纸。&lt;br&gt;&lt;img data-src=&quot;https://imzlp.com/posts/841/Momentum.webp&quot;&gt;&lt;br&gt;&lt;code&gt;Pocket&lt;/code&gt;&lt;br&gt;稍后阅读，手机端扫货电脑端整理效果更佳。&lt;/p&gt;</summary>
    
    
    
    <category term="网络工具" scheme="https://imzlp.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具集锦" scheme="https://imzlp.com/tags/%E5%B7%A5%E5%85%B7%E9%9B%86%E9%94%A6/"/>
    
  </entry>
  
  <entry>
    <title>STL中容器的构造函数</title>
    <link href="https://imzlp.com/posts/42105/"/>
    <id>https://imzlp.com/posts/42105/</id>
    <published>2015-08-18T12:44:55.000Z</published>
    <updated>2021-03-16T02:53:41.653Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;code&gt;注意&lt;/code&gt;&lt;/strong&gt;:此文档中所有的初始化皆依据以下容器&lt;/p&gt;
&lt;figure class=&quot;highlight cc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//创建vector&amp;lt;int&amp;gt;容器test,并为其赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; test;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	test.push_back(i);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="STL" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/STL/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STL" scheme="https://imzlp.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>两个迭代器初始化容器出现浮点数舍入</title>
    <link href="https://imzlp.com/posts/15409/"/>
    <id>https://imzlp.com/posts/15409/</id>
    <published>2015-08-18T12:39:17.000Z</published>
    <updated>2021-03-16T02:53:41.653Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近在整理笔记的时候发现了个奇怪的问题：&lt;br&gt;&lt;img data-src=&quot;https://imzlp.com/posts/15409/1.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>创业维艰·如何完成比难更难的事</title>
    <link href="https://imzlp.com/posts/39435/"/>
    <id>https://imzlp.com/posts/39435/</id>
    <published>2015-08-18T11:15:13.000Z</published>
    <updated>2021-03-16T02:53:41.653Z</updated>
    
    
    <summary type="html">这是一篇加密文章，请输入密码后阅读。</summary>
    
    
    
    <category term="读书笔记" scheme="https://imzlp.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="思想感悟" scheme="https://imzlp.com/tags/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    <category term="读书笔记" scheme="https://imzlp.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>顺序容器与关联容器</title>
    <link href="https://imzlp.com/posts/33878/"/>
    <id>https://imzlp.com/posts/33878/</id>
    <published>2015-02-18T13:26:31.000Z</published>
    <updated>2021-03-16T02:53:41.653Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++ STL中的顺序容器和关联容器概念和用法整理。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="STL" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/STL/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STL" scheme="https://imzlp.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++的基础语法整理</title>
    <link href="https://imzlp.com/posts/42362/"/>
    <id>https://imzlp.com/posts/42362/</id>
    <published>2015-01-20T11:50:59.000Z</published>
    <updated>2021-03-16T02:53:41.653Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++的基本语法概念整理。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="技术笔记" scheme="https://imzlp.com/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C/C++速查表</title>
    <link href="https://imzlp.com/posts/14660/"/>
    <id>https://imzlp.com/posts/14660/</id>
    <published>2015-01-15T23:56:13.000Z</published>
    <updated>2021-03-16T02:53:41.653Z</updated>
    
    
    <summary type="html">&lt;p&gt;整理的一份C/C++的速查表，平时整理下放到这里来，供方便查询。&lt;/p&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://imzlp.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
    <category term="语言" scheme="https://imzlp.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>写点自己的感悟，我的软件专业</title>
    <link href="https://imzlp.com/posts/44216/"/>
    <id>https://imzlp.com/posts/44216/</id>
    <published>2015-01-04T22:32:01.000Z</published>
    <updated>2021-03-16T02:53:41.649Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文是之前发表在我校的一个帖子，涉及自己以往学习编程的一些经历和看法，为软件专业的学弟学妹的科普解惑之用，最近被挖出来，我都快忘了，顺便整理一下，在此贴出。&lt;/p&gt;</summary>
    
    
    
    <category term="思想感悟" scheme="https://imzlp.com/categories/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="思想感悟" scheme="https://imzlp.com/tags/%E6%80%9D%E6%83%B3%E6%84%9F%E6%82%9F/"/>
    
    <category term="C++" scheme="https://imzlp.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用Github来管理博客源文件</title>
    <link href="https://imzlp.com/posts/55550/"/>
    <id>https://imzlp.com/posts/55550/</id>
    <published>2014-11-20T23:52:01.000Z</published>
    <updated>2021-03-16T02:53:41.649Z</updated>
    
    
    <summary type="html">&lt;p&gt;将博客的源文件(非hexo生成的文件)托管到Github上，方便同步和控制版本。&lt;/p&gt;</summary>
    
    
    
    <category term="博客管理" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/Hexo/"/>
    
    
    <category term="Github" scheme="https://imzlp.com/tags/Github/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/tags/Hexo/"/>
    
    <category term="Git" scheme="https://imzlp.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Github Pages+Hexo博客搭建</title>
    <link href="https://imzlp.com/posts/58952/"/>
    <id>https://imzlp.com/posts/58952/</id>
    <published>2014-11-18T11:11:11.000Z</published>
    <updated>2021-03-16T02:53:41.645Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前使用博客园，总觉得不爽，也试过自己搭建博客。&lt;br&gt;wordpress太臃肿，其他的功(界)能(面)不(不)强(好)大(看)，仔细想来想去还是用Github Pages+Hexo搭建一个静态blog吧，专注于写作。&lt;/p&gt;</summary>
    
    
    
    <category term="博客管理" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/categories/%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86/Hexo/"/>
    
    
    <category term="Github" scheme="https://imzlp.com/tags/Github/"/>
    
    <category term="Hexo" scheme="https://imzlp.com/tags/Hexo/"/>
    
    <category term="Git" scheme="https://imzlp.com/tags/Git/"/>
    
  </entry>
  
</feed>
